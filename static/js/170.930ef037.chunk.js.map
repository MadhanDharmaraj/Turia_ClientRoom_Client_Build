{"version":3,"sources":["AllDaySplitter.ts","TimeColsAxisCell.tsx","TimeBodyAxis.tsx","TimeColsView.tsx","TimeColsSlatsCoords.ts","TimeColsSlatsBody.tsx","TimeColsSlats.tsx","TimeColsSeg.ts","TimeColMoreLink.tsx","seg-web.ts","event-placement.ts","TimeColEvent.tsx","TimeColMisc.tsx","TimeCol.tsx","TimeColsContent.tsx","TimeCols.tsx","DayTimeColsSlicer.ts","DayTimeCols.tsx","time-slat-meta.ts","DayTimeColsView.tsx","options.ts","main.ts","dnd/PointerDragging.ts","dnd/ElementMirror.ts","ScrollGeomCache.ts","ElementScrollGeomCache.ts","WindowScrollGeomCache.ts","dnd/AutoScroller.ts","dnd/FeaturefulElementDragging.ts","OffsetTracker.ts","interactions/HitDragging.ts","utils.ts","interactions/DateClicking.ts","interactions/DateSelecting.ts","interactions/EventDragging.ts","interactions/EventResizing.ts","interactions/UnselectAuto.ts","interactions-external/ExternalElementDragging.ts","interactions-external/ExternalDraggable.ts","interactions-external/InferredElementDragging.ts","interactions-external/ThirdPartyDraggable.ts"],"names":["getKeyInfo","allDay","timed","getKeysForDateSpan","dateSpan","getKeysForEventDef","eventDef","DEFAULT_SLAT_LABEL_FORMAT","hour","minute","omitZeroMinute","meridiem","TimeColsAxisCell","props","classNames","isLabeled","Consumer","context","className","join","isoTimeStr","dateEnv","options","viewApi","labelFormat","slotLabelFormat","Array","isArray","hookProps","level","time","date","toDate","view","text","format","slotLabelClassNames","content","slotLabelContent","defaultContent","renderInnerContent","didMount","slotLabelDidMount","willUnmount","slotLabelWillUnmount","rootElRef","customClassNames","innerElRef","innerContent","ref","concat","render","this","slatMetas","map","slatMeta","key","DEFAULT_WEEK_NUM_FORMAT","week","allDaySplitter","AllDaySplitter","headerElRef","scrollerElRef","state","slatCoords","handleScrollTopRequest","scrollTop","scrollerEl","current","renderHeadAxis","rowKey","frameHeight","range","renderRange","navLinkAttrs","start","end","weekNumbers","defaultFormat","style","height","renderTableRowAxis","rowHeight","allDayText","allDayClassNames","allDayContent","renderAllDayInner","allDayDidMount","allDayWillUnmount","handleSlatCoords","setState","renderSimpleLayout","headerRowContent","timeContent","sections","stickyHeaderDates","push","type","isSticky","chunk","elRef","tableClassName","rowContent","outerContent","role","theme","getClass","liquid","expandRows","Boolean","viewSpec","isHeightAuto","forPrint","collapsibleWidth","cols","width","renderHScrollLayout","colCnt","dayMinWidth","ScrollGrid","pluginHooks","scrollGridImpl","Error","stickyFooterScrollbar","syncRowHeights","chunks","arg","rowSyncHeights","contentArg","colSpan","isNowIndicator","nowIndicator","clientHeight","tableColGroupNode","TimeBodyAxis","unit","nowDate","nowIndicatorTop","safeComputeTop","isAxis","top","colGroups","span","minWidth","getAllDayMaxEventProps","dayMaxEvents","dayMaxEventRows","undefined","positions","dateProfile","slotDuration","currentRange","startOfDayDate","timeMs","valueOf","slotMinTime","slotMaxTime","computeTimeTop","computeDateTop","when","duration","slatIndex","slatRemainder","len","els","length","slatCoverage","milliseconds","Math","max","min","floor","tops","getHeight","slatElRefs","i","createRef","axis","slotLaneClassNames","slotLaneContent","slotLaneDidMount","slotLaneWillUnmount","tableMinWidth","clientWidth","minHeight","TimeColsSlatsBody","componentDidMount","updateSizing","componentDidUpdate","componentWillUnmount","onCoords","elMap","offsetHeight","TimeColsSlatsCoords","currentMap","splitSegsByCol","segs","segsByCol","col","splitInteractionByCol","ui","byRow","affectedInstances","isEvent","seg","allDayDate","moreCnt","hiddenSegs","allSegs","alignmentElRef","renderMoreLinkInner","extraDateSpan","todayRange","popoverContent","renderPlainFgSegs","handleClick","title","isExpanded","popoverId","el","bottom","onClick","shortText","buildPositioning","segInputs","strictOrder","maxStackCnt","hierarchy","hiddenEntries","addSegs","hiddenGroups","web","entriesByLevel","buildNode","cacheable","lateral","siblingRange","subjectLevel","subjectLateral","levelCoords","subjectEntry","afterSubject","thickness","levelCnt","entries","entry","searchIndex","lateralStart","lateralEnd","findNextLevelSegs","nextLevelRes","buildNodes","nextLevelNodes","buildWeb","segRects","topLevelNodes","rects","processNode","node","levelCoord","stackDepth","rect","stackForward","processNodes","nodes","webToRects","totalThickness","stretchNode","startCoord","prevThickness","endCoord","allThickness","thicknessFraction","newChildren","childNode","res","newThickness","stretchWeb","pairs","sort","cmpDescPressures","extractNode","a","b","keyFunc","workFunc","cache","args","computeSegVCoords","colDate","eventMinHeight","vcoords","spanStart","spanEnd","round","DEFAULT_TIME_FORMAT","isShort","defaultTimeFormat","extraClassNames","extraHookProps","sortEventSegs","isSelectMirror","selectMirror","mirrorSegs","eventDrag","eventResize","dateSelectionSegs","interactionAffectedInstances","sortedFgSegs","fgEventSegs","eventOrder","dataAttrs","extraDataAttrs","renderFillSegs","businessHourSegs","bgEventSegs","renderFgSegs","renderNowIndicator","nowIndicatorSegs","TimeColMisc","segIsInvisible","isDragging","isResizing","isDateSelecting","renderPositionedFgSegs","eventMaxStack","eventShortHeight","eventOrderStrict","eventSelection","isMirror","segVCoords","dumbSegs","index","segPlacements","segRect","dumbSeg","computeFgSegPlacements","renderHiddenGroups","segPlacement","instanceId","eventRange","instance","isVisible","vStyle","computeSegVStyle","hStyle","computeSegHStyle","left","right","isInset","visibility","TimeColEvent","isSelected","hiddenGroup","segEntries","positionCss","segEntry","TimeColMoreLink","fillType","children","segHCoords","isRtl","shouldOverlap","slotEventOverlap","nearCoord","farCoord","zIndex","hiddenInstances","splitFgEventSegs","splitBgEventSegs","splitBusinessHourSegs","splitNowIndicatorSegs","splitDateSelectionSegs","splitEventDrag","splitEventResize","cellElRefs","cells","fgEventSegsByRow","bgEventSegsByRow","businessHourSegsByRow","nowIndicatorSegsByRow","dateSelectionSegsByRow","eventDragByRow","eventResizeByRow","cell","TimeCol","updateCoords","onColCoords","processSlotOptions","handleRootEl","registerInteractiveComponent","isHitComboAllowed","unregisterInteractiveComponent","handleScrollRequest","request","onScrollTopRequest","ceil","handleColCoords","colCoords","onSlatCoords","TimeColsSlats","TimeColsContent","scrollResponder","createScrollResponder","prevProps","update","detach","queryHit","positionLeft","positionTop","snapDuration","snapsPerSlot","colIndex","leftToIndex","topToIndex","slatTop","slatHeight","partial","snapIndex","dayDate","add","dayEl","lefts","rights","layer","snapDurationOverride","sliceRange","dayRanges","segRange","isStart","isEnd","buildDayRanges","slicer","DayTimeColsSlicer","timeColsRef","dayTableModel","TimeCols","sliceProps","sliceNowDate","ranges","headerDates","STOCK_SUB_DURATIONS","hours","minutes","seconds","buildSlatMetas","explicitLabelInterval","dayStart","Date","slatTime","slatIterator","labelInterval","slotsPerLabel","computeLabelInterval","metas","toISOString","buildTimeColsModel","dateProfileGenerator","splitProps","slotLabelInterval","hasAttachedAxis","hasDetachedAxis","headerContent","dayHeaders","dates","datesRepDistinctDays","renderIntro","allDaySlot","nextDayThreshold","colGroupNode","renderRowIntro","showWeekNumbers","headerAlignElRef","timeGridContent","DayTimeCols","TimeColsView","daySeries","touchMouseIgnoreWait","ignoreMouseDepth","listenerCnt","isWindowTouchMoveCancelled","containerEl","subjectEl","selector","handleSelector","shouldIgnoreMove","shouldWatchScroll","isTouchDragging","wasTouchScroll","handleMouseDown","ev","shouldIgnoreMouse","button","ctrlKey","isPrimaryMouseButton","tryStart","pev","createEventFromMouse","emitter","trigger","initScrollWatch","document","addEventListener","handleMouseMove","handleMouseUp","recordCoords","removeEventListener","cleanup","handleTouchStart","createEventFromTouch","targetEl","target","handleTouchMove","handleTouchEnd","window","handleTouchScroll","setTimeout","handleScroll","pageX","pageXOffset","prevScrollX","prevPageX","pageY","pageYOffset","prevScrollY","prevPageY","origEvent","isTouch","deltaX","origPageX","deltaY","origPageY","passive","onWindowTouchMove","destroy","querySubjectEl","downEl","destroyScrollWatch","cancelTouchScroll","isFirst","touches","preventDefault","sourceEl","mirrorEl","sourceElRect","parentNode","body","revertDuration","getBoundingClientRect","origScreenX","origScreenY","updateElPosition","handleMove","setIsVisible","bool","display","stop","needsRevertAnimation","callback","done","doRevertAnimation","finalSourceElRect","transition","getMirrorEl","cloneNode","classList","position","boxSizing","margin","appendChild","scrollController","doesListening","getScrollTop","scrollLeft","getScrollLeft","handleScrollChange","origScrollTop","origScrollLeft","scrollWidth","getScrollWidth","scrollHeight","getScrollHeight","getClientWidth","getClientHeight","clientRect","computeClientRect","getEventTarget","setScrollTop","getMaxScrollTop","setScrollLeft","getMaxScrollLeft","ScrollGeomCache","getTime","performance","now","isEnabled","scrollQuery","edgeThreshold","maxVelocity","pointerScreenX","pointerScreenY","isAnimating","scrollCaches","everMovedUp","everMovedDown","everMovedLeft","everMovedRight","animate","edge","computeBestEdge","handleSide","msSinceRequest","requestAnimation","scrollStartEl","buildCaches","yDelta","xDelta","requestAnimationFrame","scrollCache","invDistance","distance","velocity","sign","name","bestSide","leftDist","rightDist","topDist","bottomDist","canScrollUp","canScrollDown","canScrollLeft","canScrollRight","queryScrollEls","WindowScrollGeomCache","ElementScrollGeomCache","query","prototype","slice","call","querySelectorAll","delay","minDistance","touchScrollAllowed","mirrorNeedsRevert","isInteracting","isDelayEnded","isDistanceSurpassed","delayTimeoutId","onPointerDown","pointer","mirror","startDelay","handleDistanceSurpassed","onPointerMove","autoScroller","onPointerUp","tryStopDrag","clearTimeout","PointerDragging","on","ElementMirror","AutoScroller","handleDelayEnd","tryStartDrag","stopDrag","bind","setIgnoreMove","setMirrorIsVisible","setMirrorNeedsRevert","setAutoScrollEnabled","origRect","scrollEl","computeLeft","computeTop","isWithinClipping","point","isIgnoredClipping","tagName","dragging","droppableStore","useSubjectCenter","requireInitial","initialHit","movingHit","finalHit","handlePointerDown","prepareHits","processFirstCoord","handleDragStart","handleDragMove","handlePointerUp","releaseHits","handleDragEnd","subjectRect","origPoint","adjustedPoint","HTMLElement","queryHitForOffset","slicedSubjectRect","coordAdjust","forceHandle","hit","isHitsEqual","offsetTrackers","interactionSettings","component","OffsetTracker","id","offsetLeft","offsetTop","bestHit","offsetTracker","originLeft","originTop","activeRange","componentId","hit0","hit1","buildDatePointApiWithContext","datePointTransforms","transform","dateStr","formatIso","omitTime","settings","isValidDateDownEl","hitDragging","jsEvent","calendarApi","FeaturefulElementDragging","HitDragging","dragSelection","canSelect","selectable","selectLongPressDelay","longPressDelay","getComponentTouchDelay","unselect","handleHitUpdate","isFinal","isInvalid","dateSelectionTransformers","dateSpan0","dateSpan1","ms","transformer","joinHitsIntoSelection","dispatch","selection","selectMinDistance","dragScroll","subjectSeg","relevantEvents","receivingContext","validMutation","mutatedRelevantEvents","origTarget","initialContext","eventInstanceId","getCurrentData","eventStore","eventDragMinDistance","eventLongPressDelay","fixedMirrorParent","dragRevertDuration","isValid","isValidSegDownEl","contains","event","def","mutation","interaction","affectedEvents","mutatedEvents","receivingOptions","editable","droppable","massagers","date0","date1","standardProps","hasEnd","allDayMaintainDuration","delta","largeUnit","datesDelta","massager","computeEventMutation","eventDragMutationMassagers","eventUiBases","displayDrag","querySelector","initialView","eventInstance","eventApi","clearDrag","updatedEventApi","defs","defId","instances","eventChangeArg","oldEvent","relatedEvents","revert","transformed","eventDropTransformers","eventRemoveArg","draggedEl","addedEventDef","addedEventInstance","addedEventApi","eventAddArg","EventDragging","SELECTOR","useEventCenter","nextContext","prevContext","initialCalendar","draggingSegEl","draggingSeg","segEl","querySegEl","isFromStart","instanceRange","startDelta","endDelta","computeMutation","isRecentPointerDateSelect","matchesCancel","matchesEvent","onSelect","selectInfo","onDocumentPointerDown","unselectCancel","onDocumentPointerUp","documentPointer","calendarState","dateSelection","unselectAuto","off","OPTION_REFINERS","LISTENER_REFINERS","dateClick","eventDragStart","eventDragStop","eventDrop","eventResizeStart","eventResizeStop","drop","eventReceive","eventLeave","suppliedDragMeta","droppableEvent","dragMeta","buildDragMeta","create","canDropElOnCalendar","defProps","leftoverProps","externalDefTransforms","refined","extra","sourceId","forceEventDuration","startTime","computeEventForDateSpan","finalView","str","prefix","dataAttrPrefix","prefixedName","getAttribute","getEmbeddedElData","obj","JSON","parse","getDragMetaFromEl","dropAccept","itemSelector","appendTo","ExternalElementDragging","eventData","mirrorSelector","currentMirrorEl","handlePointerMove","containerOrSettings","Element","InferredElementDragging","componentInteractions","DateClicking","DateSelecting","EventResizing","calendarInteractions","UnselectAuto","elementDraggingImpl","optionRefiners","listenerRefiners"],"mappings":"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","file":"static/js/170.930ef037.chunk.js","sourcesContent":["import {\n  Splitter,\n  hasBgRendering,\n  EventDef,\n  DateSpan,\n} from '@fullcalendar/common'\n\nexport class AllDaySplitter extends Splitter {\n  getKeyInfo() {\n    return {\n      allDay: {},\n      timed: {},\n    }\n  }\n\n  getKeysForDateSpan(dateSpan: DateSpan): string[] {\n    if (dateSpan.allDay) {\n      return ['allDay']\n    }\n\n    return ['timed']\n  }\n\n  getKeysForEventDef(eventDef: EventDef): string[] {\n    if (!eventDef.allDay) {\n      return ['timed']\n    }\n\n    if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay']\n    }\n\n    return ['allDay']\n  }\n}\n","import {\n  createElement,\n  ViewContext,\n  createFormatter,\n  ViewContextType,\n  RenderHook,\n  SlotLabelContentArg,\n} from '@fullcalendar/common'\nimport { TimeSlatMeta } from './time-slat-meta'\n\nconst DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short',\n})\n\nexport function TimeColsAxisCell(props: TimeSlatMeta) {\n  let classNames = [\n    'fc-timegrid-slot',\n    'fc-timegrid-slot-label',\n    props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor',\n  ]\n\n  return (\n    <ViewContextType.Consumer>\n      {(context: ViewContext) => {\n        if (!props.isLabeled) {\n          return (\n            <td className={classNames.join(' ')} data-time={props.isoTimeStr} />\n          )\n        }\n\n        let { dateEnv, options, viewApi } = context\n        let labelFormat = // TODO: fully pre-parse\n          options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT :\n            Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) :\n              createFormatter(options.slotLabelFormat)\n\n        let hookProps: SlotLabelContentArg = {\n          level: 0,\n          time: props.time,\n          date: dateEnv.toDate(props.date),\n          view: viewApi,\n          text: dateEnv.format(props.date, labelFormat),\n        }\n\n        return (\n          <RenderHook<SlotLabelContentArg> // needed?\n            hookProps={hookProps}\n            classNames={options.slotLabelClassNames}\n            content={options.slotLabelContent}\n            defaultContent={renderInnerContent}\n            didMount={options.slotLabelDidMount}\n            willUnmount={options.slotLabelWillUnmount}\n          >\n            {(rootElRef, customClassNames, innerElRef, innerContent) => (\n              <td ref={rootElRef} className={classNames.concat(customClassNames).join(' ')} data-time={props.isoTimeStr}>\n                <div className=\"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\">\n                  <div className=\"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\" ref={innerElRef}>\n                    {innerContent}\n                  </div>\n                </div>\n              </td>\n            )}\n          </RenderHook>\n        )\n      }}\n    </ViewContextType.Consumer>\n  )\n}\n\nfunction renderInnerContent(props) { // TODO: add types\n  return props.text\n}\n","import { createElement, BaseComponent } from '@fullcalendar/common'\nimport { TimeColsAxisCell } from './TimeColsAxisCell'\nimport { TimeSlatMeta } from './time-slat-meta'\n\n/* Thin Axis\n------------------------------------------------------------------------------------------------------------------*/\n\ninterface TimeBodyAxisProps {\n  slatMetas: TimeSlatMeta[]\n}\n\nexport class TimeBodyAxis extends BaseComponent<TimeBodyAxisProps> { // just <tr> content\n  render() {\n    return this.props.slatMetas.map((slatMeta: TimeSlatMeta) => (\n      <tr key={slatMeta.key}>\n        <TimeColsAxisCell {...slatMeta} />\n      </tr>\n    ))\n  }\n}\n","import {\n  createElement, createRef,\n  diffDays,\n  SimpleScrollGridSection,\n  VNode,\n  SimpleScrollGrid,\n  ChunkContentCallbackArgs,\n  ScrollGridSectionConfig,\n  buildNavLinkAttrs,\n  ViewRoot,\n  WeekNumberRoot,\n  RenderHook,\n  DateComponent,\n  ViewProps,\n  RefObject,\n  renderScrollShim,\n  getStickyHeaderDates,\n  getStickyFooterScrollbar,\n  createFormatter,\n  AllDayContentArg,\n  CssDimValue,\n  NowTimer,\n  DateMarker,\n  NowIndicatorRoot,\n} from '@fullcalendar/common'\nimport { AllDaySplitter } from './AllDaySplitter'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeBodyAxis } from './TimeBodyAxis'\n\nconst DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: 'short' })\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5\n\n/* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.\n----------------------------------------------------------------------------------------------------------------------*/\n// Is a manager for the TimeCols subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n// Responsible for managing width/height.\n\ninterface TimeColsViewState {\n  slatCoords: TimeColsSlatsCoords | null\n}\n\nexport abstract class TimeColsView extends DateComponent<ViewProps, TimeColsViewState> {\n  protected allDaySplitter = new AllDaySplitter() // for use by subclasses\n\n  protected headerElRef: RefObject<HTMLTableCellElement> = createRef<HTMLTableCellElement>()\n  private rootElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n  private scrollerElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n\n  state = {\n    slatCoords: null,\n  }\n\n  // rendering\n  // ----------------------------------------------------------------------------------------------------\n\n  renderSimpleLayout(\n    headerRowContent: VNode | null,\n    allDayContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    timeContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n  ) {\n    let { context, props } = this\n    let sections: SimpleScrollGridSection[] = []\n    let stickyHeaderDates = getStickyHeaderDates(context.options)\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent,\n        },\n      })\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: { content: allDayContent },\n      })\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n          <tr role=\"presentation\" className=\"fc-scrollgrid-section\">\n            <td\n              className={'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')}\n            />\n          </tr>\n        ),\n      })\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent,\n      },\n    })\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec} elRef={this.rootElRef}>\n        {(rootElRef, classNames) => (\n          <div className={['fc-timegrid'].concat(classNames).join(' ')} ref={rootElRef}>\n            <SimpleScrollGrid\n              liquid={!props.isHeightAuto && !props.forPrint}\n              collapsibleWidth={props.forPrint}\n              cols={[{ width: 'shrink' }]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n  renderHScrollLayout(\n    headerRowContent: VNode | null,\n    allDayContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    timeContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    colCnt: number,\n    dayMinWidth: number,\n    slatMetas: TimeSlatMeta[],\n    slatCoords: TimeColsSlatsCoords | null, // yuck\n  ) {\n    let ScrollGrid = this.context.pluginHooks.scrollGridImpl\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation')\n    }\n\n    let { context, props } = this\n    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options)\n    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options)\n    let sections: ScrollGridSectionConfig[] = []\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [\n          {\n            key: 'axis',\n            rowContent: (arg: ChunkContentCallbackArgs) => (\n              <tr role=\"presentation\">\n                {this.renderHeadAxis('day', arg.rowSyncHeights[0])}\n              </tr>\n            ),\n          },\n          {\n            key: 'cols',\n            elRef: this.headerElRef,\n            tableClassName: 'fc-col-header',\n            rowContent: headerRowContent,\n          },\n        ],\n      })\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [\n          {\n            key: 'axis',\n            rowContent: (contentArg: ChunkContentCallbackArgs) => (\n              <tr role=\"presentation\">\n                {this.renderTableRowAxis(contentArg.rowSyncHeights[0])}\n              </tr>\n            ),\n          },\n          {\n            key: 'cols',\n            content: allDayContent,\n          },\n        ],\n      })\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n          <tr role=\"presentation\" className=\"fc-scrollgrid-section\">\n            <td\n              colSpan={2}\n              className={'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')}\n            />\n          </tr>\n        ),\n      })\n    }\n\n    let isNowIndicator = context.options.nowIndicator\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [\n        {\n          key: 'axis',\n          content: (arg) => (\n            // TODO: make this now-indicator arrow more DRY with TimeColsContent\n            <div className=\"fc-timegrid-axis-chunk\">\n              <table aria-hidden style={{ height: arg.expandRows ? arg.clientHeight : '' }}>\n                {arg.tableColGroupNode}\n                <tbody>\n                  <TimeBodyAxis slatMetas={slatMetas} />\n                </tbody>\n              </table>\n              <div className=\"fc-timegrid-now-indicator-container\">\n                <NowTimer unit={isNowIndicator ? 'minute' : 'day' /* hacky */}>\n                  {(nowDate: DateMarker) => {\n                    let nowIndicatorTop =\n                      isNowIndicator &&\n                      slatCoords &&\n                      slatCoords.safeComputeTop(nowDate) // might return void\n\n                    if (typeof nowIndicatorTop === 'number') {\n                      return (\n                        <NowIndicatorRoot isAxis date={nowDate}>\n                          {(rootElRef, classNames, innerElRef, innerContent) => (\n                            <div\n                              ref={rootElRef}\n                              className={['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' ')}\n                              style={{ top: nowIndicatorTop }}\n                            >\n                              {innerContent}\n                            </div>\n                          )}\n                        </NowIndicatorRoot>\n                      )\n                    }\n\n                    return null\n                  }}\n                </NowTimer>\n              </div>\n            </div>\n          ),\n        },\n        {\n          key: 'cols',\n          scrollerElRef: this.scrollerElRef,\n          content: timeContent,\n        },\n      ],\n    })\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [\n          {\n            key: 'axis',\n            content: renderScrollShim,\n          },\n          {\n            key: 'cols',\n            content: renderScrollShim,\n          },\n        ],\n      })\n    }\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec} elRef={this.rootElRef}>\n        {(rootElRef, classNames) => (\n          <div className={['fc-timegrid'].concat(classNames).join(' ')} ref={rootElRef}>\n            <ScrollGrid\n              liquid={!props.isHeightAuto && !props.forPrint}\n              collapsibleWidth={false}\n              colGroups={[\n                { width: 'shrink', cols: [{ width: 'shrink' }] }, // TODO: allow no specify cols\n                { cols: [{ span: colCnt, minWidth: dayMinWidth }] },\n              ]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n  handleScrollTopRequest = (scrollTop: number) => {\n    let scrollerEl = this.scrollerElRef.current\n\n    if (scrollerEl) { // TODO: not sure how this could ever be null. weirdness with the reducer\n      scrollerEl.scrollTop = scrollTop\n    }\n  }\n\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  getAllDayMaxEventProps() {\n    let { dayMaxEvents, dayMaxEventRows } = this.context.options\n\n    if (dayMaxEvents === true || dayMaxEventRows === true) { // is auto?\n      dayMaxEvents = undefined\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS // make sure \"auto\" goes to a real number\n    }\n\n    return { dayMaxEvents, dayMaxEventRows }\n  }\n\n  /* Header Render Methods\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  renderHeadAxis = (rowKey: 'day' | string, frameHeight: CssDimValue = '') => {\n    let { options } = this.context\n    let { dateProfile } = this.props\n    let range = dateProfile.renderRange\n    let dayCnt = diffDays(range.start, range.end)\n\n    let navLinkAttrs = (dayCnt === 1) // only do in day views (to avoid doing in week views that dont need it)\n      ? buildNavLinkAttrs(this.context, range.start, 'week')\n      : {}\n\n    if (options.weekNumbers && rowKey === 'day') {\n      return (\n        <WeekNumberRoot date={range.start} defaultFormat={DEFAULT_WEEK_NUM_FORMAT}>\n          {(rootElRef, classNames, innerElRef, innerContent) => (\n            <th\n              ref={rootElRef}\n              aria-hidden\n              className={[\n                'fc-timegrid-axis',\n                'fc-scrollgrid-shrink',\n              ].concat(classNames).join(' ')}\n            >\n              <div\n                className=\"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\"\n                style={{ height: frameHeight }}\n              >\n                <a\n                  ref={innerElRef}\n                  className=\"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n                  {...navLinkAttrs}\n                >\n                  {innerContent}\n                </a>\n              </div>\n            </th>\n          )}\n        </WeekNumberRoot>\n      )\n    }\n\n    return (\n      <th aria-hidden className=\"fc-timegrid-axis\">\n        <div className=\"fc-timegrid-axis-frame\" style={{ height: frameHeight }} />\n      </th>\n    )\n  }\n\n  /* Table Component Render Methods\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n  // but DayGrid still needs to have classNames on inner elements in order to measure.\n  renderTableRowAxis = (rowHeight?: number) => {\n    let { options, viewApi } = this.context\n    let hookProps: AllDayContentArg = {\n      text: options.allDayText,\n      view: viewApi,\n    }\n\n    return (\n      // TODO: make reusable hook. used in list view too\n      <RenderHook<AllDayContentArg>\n        hookProps={hookProps}\n        classNames={options.allDayClassNames}\n        content={options.allDayContent}\n        defaultContent={renderAllDayInner}\n        didMount={options.allDayDidMount}\n        willUnmount={options.allDayWillUnmount}\n      >\n        {(rootElRef, classNames, innerElRef, innerContent) => (\n          <td\n            ref={rootElRef}\n            aria-hidden\n            className={[\n              'fc-timegrid-axis',\n              'fc-scrollgrid-shrink',\n            ].concat(classNames).join(' ')}\n          >\n            <div\n              className={'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : '')}\n              style={{ height: rowHeight }}\n            >\n              <span className=\"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\" ref={innerElRef}>\n                {innerContent}\n              </span>\n            </div>\n          </td>\n        )}\n      </RenderHook>\n    )\n  }\n\n  handleSlatCoords = (slatCoords: TimeColsSlatsCoords) => {\n    this.setState({ slatCoords })\n  }\n}\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text\n}\n","import {\n  PositionCache,\n  DateMarker,\n  startOfDay,\n  createDuration,\n  asRoughMs,\n  DateProfile,\n  Duration,\n  rangeContainsMarker,\n} from '@fullcalendar/common'\n\nexport class TimeColsSlatsCoords {\n  constructor(\n    public positions: PositionCache,\n    private dateProfile: DateProfile,\n    private slotDuration: Duration,\n  ) {\n  }\n\n  safeComputeTop(date: DateMarker) { // TODO: DRY with computeDateTop\n    let { dateProfile } = this\n\n    if (rangeContainsMarker(dateProfile.currentRange, date)) {\n      let startOfDayDate = startOfDay(date)\n      let timeMs = date.valueOf() - startOfDayDate.valueOf()\n\n      if (\n        timeMs >= asRoughMs(dateProfile.slotMinTime) &&\n        timeMs < asRoughMs(dateProfile.slotMaxTime)\n      ) {\n        return this.computeTimeTop(createDuration(timeMs))\n      }\n    }\n\n    return null\n  }\n\n  // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  computeDateTop(when: DateMarker, startOfDayDate?: DateMarker) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when)\n    }\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()))\n  }\n\n  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n  computeTimeTop(duration: Duration): number {\n    let { positions, dateProfile } = this\n    let len = positions.els.length\n\n    // floating-point value of # of slots covered\n    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration)\n    let slatIndex\n    let slatRemainder\n\n    // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n    slatCoverage = Math.max(0, slatCoverage)\n    slatCoverage = Math.min(len, slatCoverage)\n\n    // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n    slatIndex = Math.floor(slatCoverage)\n    slatIndex = Math.min(slatIndex, len - 1)\n\n    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n    slatRemainder = slatCoverage - slatIndex\n\n    return positions.tops[slatIndex] +\n      positions.getHeight(slatIndex) * slatRemainder\n  }\n}\n","import {\n  createElement,\n  BaseComponent,\n  RefMap,\n  RenderHook,\n  SlotLaneContentArg,\n} from '@fullcalendar/common'\nimport { TimeColsAxisCell } from './TimeColsAxisCell'\nimport { TimeSlatMeta } from './time-slat-meta'\n\nexport interface TimeColsSlatsBodyProps {\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n  slatElRefs: RefMap<HTMLTableRowElement>\n}\n\nexport class TimeColsSlatsBody extends BaseComponent<TimeColsSlatsBodyProps> {\n  render() {\n    let { props, context } = this\n    let { options } = context\n    let { slatElRefs } = props\n\n    return (\n      <tbody>\n        {props.slatMetas.map((slatMeta, i) => {\n          let hookProps: SlotLaneContentArg = {\n            time: slatMeta.time,\n            date: context.dateEnv.toDate(slatMeta.date),\n            view: context.viewApi,\n          }\n\n          let classNames = [\n            'fc-timegrid-slot',\n            'fc-timegrid-slot-lane',\n            slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor',\n          ]\n\n          return (\n            <tr\n              key={slatMeta.key}\n              ref={slatElRefs.createRef(slatMeta.key)}\n            >\n              {props.axis && (\n                <TimeColsAxisCell {...slatMeta} />\n              )}\n              <RenderHook\n                hookProps={hookProps}\n                classNames={options.slotLaneClassNames}\n                content={options.slotLaneContent}\n                didMount={options.slotLaneDidMount}\n                willUnmount={options.slotLaneWillUnmount}\n              >\n                {(rootElRef, customClassNames, innerElRef, innerContent) => (\n                  <td\n                    ref={rootElRef}\n                    className={classNames.concat(customClassNames).join(' ')}\n                    data-time={slatMeta.isoTimeStr}\n                  >\n                    {innerContent}\n                  </td>\n                )}\n              </RenderHook>\n            </tr>\n          )\n        })}\n      </tbody>\n    )\n  }\n}\n","import {\n  createElement,\n  VNode,\n  BaseComponent,\n  RefMap,\n  CssDimValue,\n  createRef,\n  PositionCache,\n  DateProfile,\n} from '@fullcalendar/common'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeColsSlatsBody } from './TimeColsSlatsBody'\n\nexport interface TimeColsSlatsProps extends TimeColsSlatsContentProps {\n  dateProfile: DateProfile\n  clientWidth: number | null\n  minHeight: CssDimValue\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  onCoords?: (coords: TimeColsSlatsCoords | null) => void\n}\n\ninterface TimeColsSlatsContentProps {\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n}\n\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\n\nexport class TimeColsSlats extends BaseComponent<TimeColsSlatsProps> {\n  private rootElRef = createRef<HTMLDivElement>()\n  private slatElRefs = new RefMap<HTMLTableRowElement>()\n\n  render() {\n    let { props, context } = this\n\n    return (\n      <div ref={this.rootElRef} className=\"fc-timegrid-slots\">\n        <table\n          aria-hidden\n          className={context.theme.getClass('table')}\n          style={{\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth,\n            height: props.minHeight,\n          }}\n        >\n          {props.tableColGroupNode /* relies on there only being a single <col> for the axis */}\n          <TimeColsSlatsBody\n            slatElRefs={this.slatElRefs}\n            axis={props.axis}\n            slatMetas={props.slatMetas}\n          />\n        </table>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSizing()\n  }\n\n  componentDidUpdate() {\n    this.updateSizing()\n  }\n\n  componentWillUnmount() {\n    if (this.props.onCoords) {\n      this.props.onCoords(null)\n    }\n  }\n\n  updateSizing() {\n    let { context, props } = this\n\n    if (\n      props.onCoords &&\n      props.clientWidth !== null // means sizing has stabilized\n    ) {\n      let rootEl = this.rootElRef.current\n\n      if (rootEl.offsetHeight) { // not hidden by css\n        props.onCoords(\n          new TimeColsSlatsCoords(\n            new PositionCache(\n              this.rootElRef.current,\n              collectSlatEls(this.slatElRefs.currentMap, props.slatMetas),\n              false,\n              true, // vertical\n            ),\n            this.props.dateProfile,\n            context.options.slotDuration,\n          ),\n        )\n      }\n    }\n  }\n}\n\nfunction collectSlatEls(elMap: { [key: string]: HTMLElement }, slatMetas: TimeSlatMeta[]) {\n  return slatMetas.map((slatMeta) => elMap[slatMeta.key])\n}\n","import { DateMarker, Seg, EventSegUiInteractionState } from '@fullcalendar/common'\n\n// JUST A DATA STRUCTURE, not a component\n\nexport interface TimeColsSeg extends Seg {\n  col: number\n  start: DateMarker\n  end: DateMarker\n}\n\nexport function splitSegsByCol(segs: TimeColsSeg[] | null, colCnt: number) { // can be given null/undefined!\n  let segsByCol: TimeColsSeg[][] = []\n  let i\n\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([])\n  }\n\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i])\n    }\n  }\n\n  return segsByCol\n}\n\nexport function splitInteractionByCol(ui: EventSegUiInteractionState | null, colCnt: number) {\n  let byRow: EventSegUiInteractionState[] = []\n\n  if (!ui) {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = null\n    }\n  } else {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: [],\n      }\n    }\n\n    for (let seg of ui.segs) {\n      byRow[seg.col].segs.push(seg)\n    }\n  }\n\n  return byRow\n}\n","import {\n  createElement, MoreLinkContentArg, MoreLinkRoot, BaseComponent, createRef, setRef,\n  Dictionary, DateProfile, DateRange, DateMarker, EventSegUiInteractionState, CssDimValue,\n} from '@fullcalendar/common'\nimport { renderPlainFgSegs } from './TimeCol'\nimport { TimeColsSeg } from './TimeColsSeg'\n\nexport interface TimeColMoreLinkProps {\n  hiddenSegs: TimeColsSeg[]\n  top: CssDimValue\n  bottom: CssDimValue\n  extraDateSpan?: Dictionary\n  dateProfile: DateProfile\n  todayRange: DateRange\n  nowDate: DateMarker\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState\n  eventResize: EventSegUiInteractionState\n}\n\nexport class TimeColMoreLink extends BaseComponent<TimeColMoreLinkProps> {\n  rootElRef = createRef<HTMLElement>()\n\n  render() {\n    let { props } = this\n    return (\n      <MoreLinkRoot\n        allDayDate={null}\n        moreCnt={props.hiddenSegs.length}\n        allSegs={props.hiddenSegs}\n        hiddenSegs={props.hiddenSegs}\n        alignmentElRef={this.rootElRef}\n        defaultContent={renderMoreLinkInner}\n        extraDateSpan={props.extraDateSpan}\n        dateProfile={props.dateProfile}\n        todayRange={props.todayRange}\n        popoverContent={() => renderPlainFgSegs(props.hiddenSegs, props)}\n      >\n        {(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) => (\n          <a\n            ref={(el: HTMLElement | null) => {\n              setRef(rootElRef, el)\n              setRef(this.rootElRef, el)\n            }}\n            className={['fc-timegrid-more-link'].concat(classNames).join(' ')}\n            style={{ top: props.top, bottom: props.bottom }}\n            onClick={handleClick}\n            title={title}\n            aria-expanded={isExpanded}\n            aria-controls={popoverId}\n          >\n            <div ref={innerElRef} className=\"fc-timegrid-more-link-inner fc-sticky\">\n              {innerContent}\n            </div>\n          </a>\n        )}\n      </MoreLinkRoot>\n    )\n  }\n}\n\nfunction renderMoreLinkInner(props: MoreLinkContentArg) {\n  return props.shortText\n}\n","import {\n  SegEntry,\n  SegHierarchy,\n  SegRect,\n  buildEntryKey,\n  getEntrySpanEnd,\n  binarySearch,\n  SegEntryGroup,\n  groupIntersectingEntries,\n} from '@fullcalendar/common'\n\ninterface SegNode extends SegEntry {\n  nextLevelNodes: SegNode[] // with highest-pressure first\n}\n\ntype SegNodeAndPressure = [ SegNode, number ]\n\ninterface SegSiblingRange { // will ALWAYS have span of 1 or more items. if not, will be null\n  level: number\n  lateralStart: number\n  lateralEnd: number\n}\n\nexport interface SegWebRect extends SegRect {\n  stackDepth: number\n  stackForward: number\n}\n\n// segInputs assumed sorted\nexport function buildPositioning(\n  segInputs: SegEntry[],\n  strictOrder?: boolean,\n  maxStackCnt?: number,\n): { segRects: SegWebRect[], hiddenGroups: SegEntryGroup[] } {\n  let hierarchy = new SegHierarchy()\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt\n  }\n\n  let hiddenEntries = hierarchy.addSegs(segInputs)\n  let hiddenGroups = groupIntersectingEntries(hiddenEntries)\n\n  let web = buildWeb(hierarchy)\n  web = stretchWeb(web, 1) // all levelCoords/thickness will have 0.0-1.0\n  let segRects = webToRects(web)\n\n  return { segRects, hiddenGroups }\n}\n\nfunction buildWeb(hierarchy: SegHierarchy): SegNode[] {\n  const { entriesByLevel } = hierarchy\n\n  const buildNode = cacheable(\n    (level: number, lateral: number) => level + ':' + lateral,\n    (level: number, lateral: number): SegNodeAndPressure => {\n      let siblingRange = findNextLevelSegs(hierarchy, level, lateral)\n      let nextLevelRes = buildNodes(siblingRange, buildNode)\n      let entry = entriesByLevel[level][lateral]\n\n      return [\n        { ...entry, nextLevelNodes: nextLevelRes[0] },\n        entry.thickness + nextLevelRes[1], // the pressure builds\n      ]\n    },\n  )\n\n  return buildNodes(\n    entriesByLevel.length\n      ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length }\n      : null,\n    buildNode,\n  )[0]\n}\n\nfunction buildNodes(\n  siblingRange: SegSiblingRange | null,\n  buildNode: (level: number, lateral: number) => SegNodeAndPressure,\n): [SegNode[], number] { // number is maxPressure\n  if (!siblingRange) {\n    return [[], 0]\n  }\n\n  let { level, lateralStart, lateralEnd } = siblingRange\n  let lateral = lateralStart\n  let pairs: SegNodeAndPressure[] = []\n\n  while (lateral < lateralEnd) {\n    pairs.push(buildNode(level, lateral))\n    lateral += 1\n  }\n\n  pairs.sort(cmpDescPressures)\n\n  return [\n    pairs.map(extractNode),\n    pairs[0][1], // first item's pressure\n  ]\n}\n\nfunction cmpDescPressures(a: SegNodeAndPressure, b: SegNodeAndPressure) { // sort pressure high -> low\n  return b[1] - a[1]\n}\n\nfunction extractNode(a: SegNodeAndPressure): SegNode {\n  return a[0]\n}\n\nfunction findNextLevelSegs(hierarchy: SegHierarchy, subjectLevel: number, subjectLateral: number): SegSiblingRange | null {\n  let { levelCoords, entriesByLevel } = hierarchy\n  let subjectEntry = entriesByLevel[subjectLevel][subjectLateral]\n  let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness\n  let levelCnt = levelCoords.length\n  let level = subjectLevel\n\n  // skip past levels that are too high up\n  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1) ; // do nothing\n\n  for (; level < levelCnt; level += 1) {\n    let entries = entriesByLevel[level]\n    let entry: SegEntry\n    let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd)\n    let lateralStart = searchIndex[0] + searchIndex[1] // if exact match (which doesn't collide), go to next one\n    let lateralEnd = lateralStart\n\n    while ( // loop through entries that horizontally intersect\n      (entry = entries[lateralEnd]) && // but not past the whole seg list\n      entry.span.start < subjectEntry.span.end\n    ) { lateralEnd += 1 }\n\n    if (lateralStart < lateralEnd) {\n      return { level, lateralStart, lateralEnd }\n    }\n  }\n\n  return null\n}\n\nfunction stretchWeb(topLevelNodes: SegNode[], totalThickness: number): SegNode[] {\n  const stretchNode = cacheable(\n    (node: SegNode, startCoord: number, prevThickness: number) => buildEntryKey(node),\n    (node: SegNode, startCoord: number, prevThickness: number): [number, SegNode] => { // [startCoord, node]\n      let { nextLevelNodes, thickness } = node\n      let allThickness = thickness + prevThickness\n      let thicknessFraction = thickness / allThickness\n      let endCoord: number\n      let newChildren: SegNode[] = []\n\n      if (!nextLevelNodes.length) {\n        endCoord = totalThickness\n      } else {\n        for (let childNode of nextLevelNodes) {\n          if (endCoord === undefined) {\n            let res = stretchNode(childNode, startCoord, allThickness)\n            endCoord = res[0]\n            newChildren.push(res[1])\n          } else {\n            let res = stretchNode(childNode, endCoord, 0)\n            newChildren.push(res[1])\n          }\n        }\n      }\n\n      let newThickness = (endCoord - startCoord) * thicknessFraction\n      return [endCoord - newThickness, {\n        ...node,\n        thickness: newThickness,\n        nextLevelNodes: newChildren,\n      }]\n    },\n  )\n\n  return topLevelNodes.map((node: SegNode) => stretchNode(node, 0, 0)[1])\n}\n\n// not sorted in any particular order\nfunction webToRects(topLevelNodes: SegNode[]): SegWebRect[] {\n  let rects: SegWebRect[] = []\n\n  const processNode = cacheable(\n    (node: SegNode, levelCoord: number, stackDepth: number) => buildEntryKey(node),\n    (node: SegNode, levelCoord: number, stackDepth: number) => { // returns forwardPressure\n      let rect: SegWebRect = {\n        ...node,\n        levelCoord,\n        stackDepth,\n        stackForward: 0, // will assign after recursing\n      }\n      rects.push(rect)\n\n      return (\n        rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1\n      )\n    },\n  )\n\n  function processNodes(nodes: SegNode[], levelCoord: number, stackDepth: number) { // returns stackForward\n    let stackForward = 0\n    for (let node of nodes) {\n      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward)\n    }\n    return stackForward\n  }\n\n  processNodes(topLevelNodes, 0, 0)\n  return rects // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n\n// TODO: move to general util\n\nfunction cacheable<Args extends any[], Res>(\n  keyFunc: (...args: Args) => string,\n  workFunc: (...args: Args) => Res,\n): ((...args: Args) => Res) {\n  const cache: { [key: string]: Res } = {}\n\n  return (...args: Args) => {\n    let key = keyFunc(...args)\n    return (key in cache)\n      ? cache[key]\n      : (cache[key] = workFunc(...args))\n  }\n}\n","import {\n  SegSpan,\n  SegEntry,\n  SegEntryGroup,\n  DateMarker,\n} from '@fullcalendar/common'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { SegWebRect, buildPositioning } from './seg-web'\n\n// public interface\n// ------------------------------------------------------------------------------------------\n\nexport interface TimeColFgSegPlacement {\n  seg: TimeColsSeg\n  rect: SegWebRect | null\n}\n\nexport function computeSegVCoords(\n  segs: TimeColsSeg[],\n  colDate: DateMarker,\n  slatCoords: TimeColsSlatsCoords = null,\n  eventMinHeight: number = 0, // might be null/undefined :(\n): SegSpan[] {\n  let vcoords: SegSpan[] = []\n\n  if (slatCoords) {\n    for (let i = 0; i < segs.length; i += 1) {\n      let seg = segs[i]\n      let spanStart = slatCoords.computeDateTop(seg.start, colDate)\n      let spanEnd = Math.max(\n        spanStart + (eventMinHeight || 0), // :(\n        slatCoords.computeDateTop(seg.end, colDate),\n      )\n      vcoords.push({\n        start: Math.round(spanStart), // for barely-overlapping collisions\n        end: Math.round(spanEnd), //\n      })\n    }\n  }\n\n  return vcoords\n}\n\nexport function computeFgSegPlacements(\n  segs: TimeColsSeg[],\n  segVCoords: SegSpan[], // might not have for every seg\n  eventOrderStrict?: boolean,\n  eventMaxStack?: number,\n): { segPlacements: TimeColFgSegPlacement[], hiddenGroups: SegEntryGroup[] } {\n  let segInputs: SegEntry[] = []\n  let dumbSegs: TimeColsSeg[] = [] // segs without coords\n\n  for (let i = 0; i < segs.length; i += 1) {\n    let vcoords = segVCoords[i]\n    if (vcoords) {\n      segInputs.push({\n        index: i,\n        thickness: 1,\n        span: vcoords,\n      })\n    } else {\n      dumbSegs.push(segs[i])\n    }\n  }\n\n  let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack)\n  let segPlacements: TimeColFgSegPlacement[] = []\n\n  for (let segRect of segRects) {\n    segPlacements.push({\n      seg: segs[segRect.index],\n      rect: segRect,\n    })\n  }\n\n  for (let dumbSeg of dumbSegs) {\n    segPlacements.push({ seg: dumbSeg, rect: null })\n  }\n\n  return { segPlacements, hiddenGroups }\n}\n","import { createElement, StandardEvent, BaseComponent, MinimalEventProps, createFormatter } from '@fullcalendar/common'\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false,\n})\n\nexport interface TimeColEventProps extends MinimalEventProps {\n  isShort: boolean\n}\n\nexport class TimeColEvent extends BaseComponent<TimeColEventProps> {\n  render() {\n    let classNames = [\n      'fc-timegrid-event',\n      'fc-v-event',\n    ]\n\n    if (this.props.isShort) {\n      classNames.push('fc-timegrid-event-short')\n    }\n\n    return (\n      <StandardEvent\n        {...this.props}\n        defaultTimeFormat={DEFAULT_TIME_FORMAT}\n        extraClassNames={classNames}\n      />\n    )\n  }\n}\n","import {\n  DateMarker, BaseComponent, createElement,\n  DateRange, DayCellContent, DateProfile,\n} from '@fullcalendar/common'\n\nexport interface TimeColMiscProps { // should be given nowDate too??\n  dateProfile: DateProfile\n  date: DateMarker\n  todayRange: DateRange\n  extraHookProps?: any\n}\n\nexport class TimeColMisc extends BaseComponent<TimeColMiscProps> {\n  render() {\n    let { props } = this\n\n    return (\n      <DayCellContent date={props.date} dateProfile={props.dateProfile} todayRange={props.todayRange} extraHookProps={props.extraHookProps}>\n        {(innerElRef, innerContent) => (\n          innerContent &&\n            <div className=\"fc-timegrid-col-misc\" ref={innerElRef}>{innerContent}</div>\n        )}\n      </DayCellContent>\n    )\n  }\n}\n","import {\n  Ref, DateMarker, BaseComponent, createElement, EventSegUiInteractionState, Seg, getSegMeta,\n  DateRange, Fragment, DayCellRoot, NowIndicatorRoot, BgEvent, renderFill, buildIsoString, computeEarliestSegStart,\n  DateProfile, buildEventRangeKey, sortEventSegs, memoize, SegEntryGroup, SegEntry, Dictionary, SegSpan, CssDimValue,\n} from '@fullcalendar/common'\nimport { TimeColMoreLink } from './TimeColMoreLink'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { SegWebRect } from './seg-web'\nimport { computeFgSegPlacements, computeSegVCoords } from './event-placement'\nimport { TimeColEvent } from './TimeColEvent'\nimport { TimeColMisc } from './TimeColMisc'\n\nexport interface TimeColProps {\n  elRef?: Ref<HTMLTableCellElement>\n  dateProfile: DateProfile\n  date: DateMarker\n  nowDate: DateMarker\n  todayRange: DateRange\n  extraDataAttrs?: any\n  extraHookProps?: any\n  extraClassNames?: string[]\n  extraDateSpan?: Dictionary\n  fgEventSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  businessHourSegs: TimeColsSeg[]\n  nowIndicatorSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  slatCoords: TimeColsSlatsCoords\n  forPrint: boolean\n}\n\nexport class TimeCol extends BaseComponent<TimeColProps> {\n  sortEventSegs = memoize(sortEventSegs)\n  // TODO: memoize event-placement?\n\n  render() {\n    let { props, context } = this\n    let isSelectMirror = context.options.selectMirror\n\n    let mirrorSegs: Seg[] = // yuck\n      (props.eventDrag && props.eventDrag.segs) ||\n      (props.eventResize && props.eventResize.segs) ||\n      (isSelectMirror && props.dateSelectionSegs) ||\n      []\n\n    let interactionAffectedInstances = // TODO: messy way to compute this\n      (props.eventDrag && props.eventDrag.affectedInstances) ||\n      (props.eventResize && props.eventResize.affectedInstances) ||\n      {}\n\n    let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder) as TimeColsSeg[]\n\n    return (\n      <DayCellRoot\n        elRef={props.elRef}\n        date={props.date}\n        dateProfile={props.dateProfile}\n        todayRange={props.todayRange}\n        extraHookProps={props.extraHookProps}\n      >\n        {(rootElRef, classNames, dataAttrs) => (\n          <td\n            ref={rootElRef}\n            role=\"gridcell\"\n            className={['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')}\n            {...dataAttrs}\n            {...props.extraDataAttrs}\n          >\n            <div className=\"fc-timegrid-col-frame\">\n              <div className=\"fc-timegrid-col-bg\">\n                {this.renderFillSegs(props.businessHourSegs, 'non-business')}\n                {this.renderFillSegs(props.bgEventSegs, 'bg-event')}\n                {this.renderFillSegs(props.dateSelectionSegs, 'highlight')}\n              </div>\n              <div className=\"fc-timegrid-col-events\">\n                {this.renderFgSegs(\n                  sortedFgSegs,\n                  interactionAffectedInstances,\n                  false,\n                  false,\n                  false,\n                )}\n              </div>\n              <div className=\"fc-timegrid-col-events\">\n                {this.renderFgSegs(\n                  mirrorSegs as TimeColsSeg[],\n                  {},\n                  Boolean(props.eventDrag),\n                  Boolean(props.eventResize),\n                  Boolean(isSelectMirror),\n                )}\n              </div>\n              <div className=\"fc-timegrid-now-indicator-container\">\n                {this.renderNowIndicator(props.nowIndicatorSegs)}\n              </div>\n              <TimeColMisc\n                date={props.date}\n                dateProfile={props.dateProfile}\n                todayRange={props.todayRange}\n                extraHookProps={props.extraHookProps}\n              />\n            </div>\n          </td>\n        )}\n      </DayCellRoot>\n    )\n  }\n\n  renderFgSegs(\n    sortedFgSegs: TimeColsSeg[],\n    segIsInvisible: { [instanceId: string]: any },\n    isDragging: boolean,\n    isResizing: boolean,\n    isDateSelecting: boolean,\n  ) {\n    let { props } = this\n    if (props.forPrint) {\n      return renderPlainFgSegs(sortedFgSegs, props)\n    }\n    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting)\n  }\n\n  renderPositionedFgSegs(\n    segs: TimeColsSeg[], // if not mirror, needs to be sorted\n    segIsInvisible: { [instanceId: string]: any },\n    isDragging: boolean,\n    isResizing: boolean,\n    isDateSelecting: boolean,\n  ) {\n    let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options\n    let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props\n    let isMirror = isDragging || isResizing || isDateSelecting\n    let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight)\n    let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack)\n\n    return (\n      <Fragment>\n        {this.renderHiddenGroups(hiddenGroups, segs)}\n        {segPlacements.map((segPlacement) => {\n          let { seg, rect } = segPlacement\n          let instanceId = seg.eventRange.instance.instanceId\n          let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect)\n          let vStyle = computeSegVStyle(rect && rect.span)\n          let hStyle = (!isMirror && rect) ? this.computeSegHStyle(rect) : { left: 0, right: 0 }\n          let isInset = Boolean(rect) && rect.stackForward > 0\n          let isShort = Boolean(rect) && (rect.span.end - rect.span.start) < eventShortHeight // look at other places for this problem\n\n          return (\n            <div\n              className={\n                'fc-timegrid-event-harness' +\n                (isInset ? ' fc-timegrid-event-harness-inset' : '')\n              }\n              key={instanceId}\n              style={{\n                visibility: isVisible ? ('' as any) : 'hidden',\n                ...vStyle,\n                ...hStyle,\n              }}\n            >\n              <TimeColEvent\n                seg={seg}\n                isDragging={isDragging}\n                isResizing={isResizing}\n                isDateSelecting={isDateSelecting}\n                isSelected={instanceId === eventSelection}\n                isShort={isShort}\n                {...getSegMeta(seg, todayRange, nowDate)}\n              />\n            </div>\n          )\n        })}\n      </Fragment>\n    )\n  }\n\n  // will already have eventMinHeight applied because segInputs already had it\n  renderHiddenGroups(hiddenGroups: SegEntryGroup[], segs: TimeColsSeg[]) {\n    let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props\n    return (\n      <Fragment>\n        {hiddenGroups.map((hiddenGroup) => {\n          let positionCss = computeSegVStyle(hiddenGroup.span)\n          let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs)\n          return (\n            <TimeColMoreLink\n              key={buildIsoString(computeEarliestSegStart(hiddenSegs))}\n              hiddenSegs={hiddenSegs}\n              top={positionCss.top}\n              bottom={positionCss.bottom}\n              extraDateSpan={extraDateSpan}\n              dateProfile={dateProfile}\n              todayRange={todayRange}\n              nowDate={nowDate}\n              eventSelection={eventSelection}\n              eventDrag={eventDrag}\n              eventResize={eventResize}\n            />\n          )\n        })}\n      </Fragment>\n    )\n  }\n\n  renderFillSegs(segs: TimeColsSeg[], fillType: string) {\n    let { props, context } = this\n    let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight) // don't assume all populated\n\n    let children = segVCoords.map((vcoords, i) => {\n      let seg = segs[i]\n      return (\n        <div\n          key={buildEventRangeKey(seg.eventRange)}\n          className=\"fc-timegrid-bg-harness\"\n          style={computeSegVStyle(vcoords)}\n        >\n          {fillType === 'bg-event' ?\n            <BgEvent seg={seg} {...getSegMeta(seg, props.todayRange, props.nowDate)} /> :\n            renderFill(fillType)}\n        </div>\n      )\n    })\n\n    return <Fragment>{children}</Fragment>\n  }\n\n  renderNowIndicator(segs: TimeColsSeg[]) {\n    let { slatCoords, date } = this.props\n\n    if (!slatCoords) { return null }\n\n    return segs.map((seg, i) => (\n      <NowIndicatorRoot\n        isAxis={false}\n        date={date}\n        // key doesn't matter. will only ever be one\n        key={i} // eslint-disable-line react/no-array-index-key\n      >\n        {(rootElRef, classNames, innerElRef, innerContent) => (\n          <div\n            ref={rootElRef}\n            className={['fc-timegrid-now-indicator-line'].concat(classNames).join(' ')}\n            style={{ top: slatCoords.computeDateTop(seg.start, date) }}\n          >\n            {innerContent}\n          </div>\n        )}\n      </NowIndicatorRoot>\n    ))\n  }\n\n  computeSegHStyle(segHCoords: SegWebRect) {\n    let { isRtl, options } = this.context\n    let shouldOverlap = options.slotEventOverlap\n    let nearCoord = segHCoords.levelCoord // the left side if LTR. the right side if RTL. floating-point\n    let farCoord = segHCoords.levelCoord + segHCoords.thickness // the right side if LTR. the left side if RTL. floating-point\n    let left // amount of space from left edge, a fraction of the total width\n    let right // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2)\n    }\n\n    if (isRtl) {\n      left = 1 - farCoord\n      right = nearCoord\n    } else {\n      left = nearCoord\n      right = 1 - farCoord\n    }\n\n    let props = {\n      zIndex: segHCoords.stackDepth + 1, // convert from 0-base to 1-based\n      left: left * 100 + '%',\n      right: right * 100 + '%',\n    }\n\n    if (shouldOverlap && !segHCoords.stackForward) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2 // 10 is a guesstimate of the icon's width\n    }\n\n    return props\n  }\n}\n\nexport function renderPlainFgSegs(\n  sortedFgSegs: TimeColsSeg[],\n  { todayRange, nowDate, eventSelection, eventDrag, eventResize }: {\n    todayRange: DateRange\n    nowDate: DateMarker\n    eventSelection: string\n    eventDrag: EventSegUiInteractionState | null\n    eventResize: EventSegUiInteractionState | null\n  },\n) {\n  let hiddenInstances =\n    (eventDrag ? eventDrag.affectedInstances : null) ||\n    (eventResize ? eventResize.affectedInstances : null) ||\n    {}\n  return (\n    <Fragment>\n      {sortedFgSegs.map((seg) => {\n        let instanceId = seg.eventRange.instance.instanceId\n        return (\n          <div\n            key={instanceId}\n            style={{ visibility: hiddenInstances[instanceId] ? 'hidden' : ('' as any) }}\n          >\n            <TimeColEvent\n              seg={seg}\n              isDragging={false}\n              isResizing={false}\n              isDateSelecting={false}\n              isSelected={instanceId === eventSelection}\n              isShort={false}\n              {...getSegMeta(seg, todayRange, nowDate)}\n            />\n          </div>\n        )\n      })}\n    </Fragment>\n  )\n}\n\nfunction computeSegVStyle(segVCoords: SegSpan | null): { top: CssDimValue, bottom: CssDimValue } {\n  if (!segVCoords) {\n    return { top: '', bottom: '' }\n  }\n  return {\n    top: segVCoords.start,\n    bottom: -segVCoords.end,\n  }\n}\n\nfunction compileSegsFromEntries(\n  segEntries: SegEntry[],\n  allSegs: TimeColsSeg[],\n): TimeColsSeg[] {\n  return segEntries.map((segEntry) => allSegs[segEntry.index])\n}\n","import {\n  createElement, VNode,\n  BaseComponent,\n  EventSegUiInteractionState,\n  CssDimValue,\n  DateMarker,\n  RefMap,\n  createRef,\n  PositionCache,\n  memoize,\n  DateRange,\n  NowIndicatorRoot,\n  DateProfile,\n  DayTableCell,\n} from '@fullcalendar/common'\nimport { TimeColsSeg, splitSegsByCol, splitInteractionByCol } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeCol } from './TimeCol'\n\nexport interface TimeColsContentProps {\n  axis: boolean\n  cells: DayTableCell[]\n  dateProfile: DateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  businessHourSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  fgEventSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  nowIndicatorSegs: TimeColsSeg[]\n  clientWidth: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  slatCoords: TimeColsSlatsCoords\n  onColCoords?: (colCoords: PositionCache) => void\n  forPrint: boolean\n}\n\nexport class TimeColsContent extends BaseComponent<TimeColsContentProps> { // TODO: rename\n  private splitFgEventSegs = memoize(splitSegsByCol)\n  private splitBgEventSegs = memoize(splitSegsByCol)\n  private splitBusinessHourSegs = memoize(splitSegsByCol)\n  private splitNowIndicatorSegs = memoize(splitSegsByCol)\n  private splitDateSelectionSegs = memoize(splitSegsByCol)\n  private splitEventDrag = memoize(splitInteractionByCol)\n  private splitEventResize = memoize(splitInteractionByCol)\n  private rootElRef = createRef<HTMLDivElement>()\n  private cellElRefs = new RefMap<HTMLTableCellElement>()\n\n  render() {\n    let { props, context } = this\n    let nowIndicatorTop =\n      context.options.nowIndicator &&\n      props.slatCoords &&\n      props.slatCoords.safeComputeTop(props.nowDate) // might return void\n\n    let colCnt = props.cells.length\n    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt)\n    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt)\n    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt)\n    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt)\n    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt)\n    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt)\n    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt)\n\n    return (\n      <div className=\"fc-timegrid-cols\" ref={this.rootElRef}>\n        <table\n          role=\"presentation\"\n          style={{\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth,\n          }}\n        >\n          {props.tableColGroupNode}\n          <tbody role=\"presentation\">\n            <tr role=\"row\">\n              {props.axis && (\n                <td aria-hidden className=\"fc-timegrid-col fc-timegrid-axis\">\n                  <div className=\"fc-timegrid-col-frame\">\n                    <div className=\"fc-timegrid-now-indicator-container\">\n                      {typeof nowIndicatorTop === 'number' && (\n                        <NowIndicatorRoot isAxis date={props.nowDate}>\n                          {(rootElRef, classNames, innerElRef, innerContent) => (\n                            <div\n                              ref={rootElRef}\n                              className={['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' ')}\n                              style={{ top: nowIndicatorTop }}\n                            >\n                              {innerContent}\n                            </div>\n                          )}\n                        </NowIndicatorRoot>\n                      )}\n                    </div>\n                  </div>\n                </td>\n              )}\n              {props.cells.map((cell, i) => (\n                <TimeCol\n                  key={cell.key}\n                  elRef={this.cellElRefs.createRef(cell.key)}\n                  dateProfile={props.dateProfile}\n                  date={cell.date}\n                  nowDate={props.nowDate}\n                  todayRange={props.todayRange}\n                  extraHookProps={cell.extraHookProps}\n                  extraDataAttrs={cell.extraDataAttrs}\n                  extraClassNames={cell.extraClassNames}\n                  extraDateSpan={cell.extraDateSpan}\n                  fgEventSegs={fgEventSegsByRow[i]}\n                  bgEventSegs={bgEventSegsByRow[i]}\n                  businessHourSegs={businessHourSegsByRow[i]}\n                  nowIndicatorSegs={nowIndicatorSegsByRow[i]}\n                  dateSelectionSegs={dateSelectionSegsByRow[i]}\n                  eventDrag={eventDragByRow[i]}\n                  eventResize={eventResizeByRow[i]}\n                  slatCoords={props.slatCoords}\n                  eventSelection={props.eventSelection}\n                  forPrint={props.forPrint}\n                />\n              ))}\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.updateCoords()\n  }\n\n  componentDidUpdate() {\n    this.updateCoords()\n  }\n\n  updateCoords() {\n    let { props } = this\n\n    if (\n      props.onColCoords &&\n      props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(\n        new PositionCache(\n          this.rootElRef.current,\n          collectCellEls(this.cellElRefs.currentMap, props.cells),\n          true, // horizontal\n          false,\n        ),\n      )\n    }\n  }\n}\n\nfunction collectCellEls(elMap: { [key: string]: HTMLElement }, cells: DayTableCell[]) {\n  return cells.map((cell) => elMap[cell.key])\n}\n","import {\n  createElement, VNode,\n  addDurations,\n  multiplyDuration,\n  wholeDivideDurations,\n  DateMarker,\n  EventSegUiInteractionState,\n  memoize,\n  CssDimValue,\n  PositionCache,\n  ScrollResponder,\n  ScrollRequest,\n  DateRange,\n  Duration,\n  DateProfile,\n  DayTableCell,\n  Hit,\n  DateComponent,\n} from '@fullcalendar/common'\nimport { TimeColsSlats } from './TimeColsSlats'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsContent } from './TimeColsContent'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeColsSeg } from './TimeColsSeg'\n\nexport interface TimeColsProps {\n  cells: DayTableCell[]\n  dateProfile: DateProfile\n  slotDuration: Duration\n  nowDate: DateMarker\n  todayRange: DateRange\n  businessHourSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  fgEventSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  tableColGroupNode: VNode\n  tableMinWidth: CssDimValue\n  clientWidth: number | null\n  clientHeight: number | null\n  expandRows: boolean\n  nowIndicatorSegs: TimeColsSeg[]\n  onScrollTopRequest?: (scrollTop: number) => void\n  forPrint: boolean\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n  onSlatCoords?: (slatCoords: TimeColsSlatsCoords) => void\n  isHitComboAllowed?: (hit0: Hit, hit1: Hit) => boolean\n}\n\ninterface TimeColsState {\n  slatCoords: TimeColsSlatsCoords | null\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n\nexport class TimeCols extends DateComponent<TimeColsProps, TimeColsState> {\n  private processSlotOptions = memoize(processSlotOptions)\n  private scrollResponder: ScrollResponder\n  private colCoords: PositionCache\n\n  state = {\n    slatCoords: null,\n  }\n\n  render() {\n    let { props, state } = this\n\n    return (\n      <div\n        className=\"fc-timegrid-body\"\n        ref={this.handleRootEl}\n        style={{\n          // these props are important to give this wrapper correct dimensions for interactions\n          // TODO: if we set it here, can we avoid giving to inner tables?\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n        }}\n      >\n        <TimeColsSlats\n          axis={props.axis}\n          dateProfile={props.dateProfile}\n          slatMetas={props.slatMetas}\n          clientWidth={props.clientWidth}\n          minHeight={props.expandRows ? props.clientHeight : ''}\n          tableMinWidth={props.tableMinWidth}\n          tableColGroupNode={props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */}\n          onCoords={this.handleSlatCoords}\n        />\n        <TimeColsContent\n          cells={props.cells}\n          axis={props.axis}\n          dateProfile={props.dateProfile}\n          businessHourSegs={props.businessHourSegs}\n          bgEventSegs={props.bgEventSegs}\n          fgEventSegs={props.fgEventSegs}\n          dateSelectionSegs={props.dateSelectionSegs}\n          eventSelection={props.eventSelection}\n          eventDrag={props.eventDrag}\n          eventResize={props.eventResize}\n          todayRange={props.todayRange}\n          nowDate={props.nowDate}\n          nowIndicatorSegs={props.nowIndicatorSegs}\n          clientWidth={props.clientWidth}\n          tableMinWidth={props.tableMinWidth}\n          tableColGroupNode={props.tableColGroupNode}\n          slatCoords={state.slatCoords}\n          onColCoords={this.handleColCoords}\n          forPrint={props.forPrint}\n        />\n      </div>\n    )\n  }\n\n  handleRootEl = (el: HTMLElement | null) => {\n    if (el) {\n      this.context.registerInteractiveComponent(this, {\n        el,\n        isHitComboAllowed: this.props.isHitComboAllowed,\n      })\n    } else {\n      this.context.unregisterInteractiveComponent(this)\n    }\n  }\n\n  componentDidMount() {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)\n  }\n\n  componentDidUpdate(prevProps: TimeColsProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile)\n  }\n\n  componentWillUnmount() {\n    this.scrollResponder.detach()\n  }\n\n  handleScrollRequest = (request: ScrollRequest) => {\n    let { onScrollTopRequest } = this.props\n    let { slatCoords } = this.state\n\n    if (onScrollTopRequest && slatCoords) {\n      if (request.time) {\n        let top = slatCoords.computeTimeTop(request.time)\n        top = Math.ceil(top) // zoom can give weird floating-point values. rather scroll a little bit further\n        if (top) {\n          top += 1 // to overcome top border that slots beyond the first have. looks better\n        }\n\n        onScrollTopRequest(top)\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  handleColCoords = (colCoords: PositionCache | null) => {\n    this.colCoords = colCoords\n  }\n\n  handleSlatCoords = (slatCoords: TimeColsSlatsCoords | null) => {\n    this.setState({ slatCoords })\n\n    if (this.props.onSlatCoords) {\n      this.props.onSlatCoords(slatCoords)\n    }\n  }\n\n  queryHit(positionLeft: number, positionTop: number): Hit {\n    let { dateEnv, options } = this.context\n    let { colCoords } = this\n    let { dateProfile } = this.props\n    let { slatCoords } = this.state\n    let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration)\n\n    let colIndex = colCoords.leftToIndex(positionLeft)\n    let slatIndex = slatCoords.positions.topToIndex(positionTop)\n\n    if (colIndex != null && slatIndex != null) {\n      let cell = this.props.cells[colIndex]\n      let slatTop = slatCoords.positions.tops[slatIndex]\n      let slatHeight = slatCoords.positions.getHeight(slatIndex)\n      let partial = (positionTop - slatTop) / slatHeight // floating point number between 0 and 1\n      let localSnapIndex = Math.floor(partial * snapsPerSlot) // the snap # relative to start of slat\n      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex\n\n      let dayDate = this.props.cells[colIndex].date\n      let time = addDurations(\n        dateProfile.slotMinTime,\n        multiplyDuration(snapDuration, snapIndex),\n      )\n\n      let start = dateEnv.add(dayDate, time)\n      let end = dateEnv.add(start, snapDuration)\n\n      return {\n        dateProfile,\n        dateSpan: {\n          range: { start, end },\n          allDay: false,\n          ...cell.extraDateSpan,\n        },\n        dayEl: colCoords.els[colIndex],\n        rect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight,\n        },\n        layer: 0,\n      }\n    }\n\n    return null\n  }\n}\n\nfunction processSlotOptions(slotDuration: Duration, snapDurationOverride: Duration | null) {\n  let snapDuration = snapDurationOverride || slotDuration\n  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration)\n\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration\n    snapsPerSlot = 1\n    // TODO: say warning?\n  }\n\n  return { snapDuration, snapsPerSlot }\n}\n","import { intersectRanges, DateRange, Slicer } from '@fullcalendar/common'\nimport { TimeColsSeg } from './TimeColsSeg'\n\nexport class DayTimeColsSlicer extends Slicer<TimeColsSeg, [DateRange[]]> {\n  sliceRange(range: DateRange, dayRanges: DateRange[]): TimeColsSeg[] {\n    let segs: TimeColsSeg[] = []\n\n    for (let col = 0; col < dayRanges.length; col += 1) {\n      let segRange = intersectRanges(range, dayRanges[col])\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col,\n        })\n      }\n    }\n\n    return segs\n  }\n}\n","import {\n  createElement,\n  createRef,\n  VNode,\n  DateComponent,\n  DateProfile,\n  EventStore,\n  EventUiHash,\n  EventInteractionState,\n  DateSpan,\n  memoize,\n  DateRange,\n  DayTableModel,\n  DateEnv,\n  DateMarker,\n  NowTimer,\n  CssDimValue,\n  Duration,\n} from '@fullcalendar/common'\nimport { TimeCols } from './TimeCols'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { DayTimeColsSlicer } from './DayTimeColsSlicer'\n\nexport interface DayTimeColsProps {\n  dateProfile: DateProfile\n  dayTableModel: DayTableModel\n  axis: boolean\n  slotDuration: Duration\n  slatMetas: TimeSlatMeta[]\n  businessHours: EventStore\n  eventStore: EventStore\n  eventUiBases: EventUiHash\n  dateSelection: DateSpan | null\n  eventSelection: string\n  eventDrag: EventInteractionState | null\n  eventResize: EventInteractionState | null\n  tableColGroupNode: VNode\n  tableMinWidth: CssDimValue\n  clientWidth: number | null\n  clientHeight: number | null\n  expandRows: boolean\n  onScrollTopRequest?: (scrollTop: number) => void\n  forPrint: boolean\n  onSlatCoords?: (slatCoords: TimeColsSlatsCoords) => void\n}\n\nexport class DayTimeCols extends DateComponent<DayTimeColsProps> {\n  private buildDayRanges = memoize(buildDayRanges)\n  private slicer = new DayTimeColsSlicer()\n  private timeColsRef = createRef<TimeCols>()\n\n  render() {\n    let { props, context } = this\n    let { dateProfile, dayTableModel } = props\n\n    let isNowIndicator = context.options.nowIndicator\n    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv)\n\n    // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n    return (\n      <NowTimer unit={isNowIndicator ? 'minute' : 'day'}>\n        {(nowDate: DateMarker, todayRange: DateRange) => (\n          <TimeCols\n            ref={this.timeColsRef}\n            {...this.slicer.sliceProps(props, dateProfile, null, context, dayRanges)}\n            forPrint={props.forPrint}\n            axis={props.axis}\n            dateProfile={dateProfile}\n            slatMetas={props.slatMetas}\n            slotDuration={props.slotDuration}\n            cells={dayTableModel.cells[0]}\n            tableColGroupNode={props.tableColGroupNode}\n            tableMinWidth={props.tableMinWidth}\n            clientWidth={props.clientWidth}\n            clientHeight={props.clientHeight}\n            expandRows={props.expandRows}\n            nowDate={nowDate}\n            nowIndicatorSegs={isNowIndicator && this.slicer.sliceNowDate(nowDate, context, dayRanges)}\n            todayRange={todayRange}\n            onScrollTopRequest={props.onScrollTopRequest}\n            onSlatCoords={props.onSlatCoords}\n          />\n        )}\n      </NowTimer>\n    )\n  }\n}\n\nexport function buildDayRanges(dayTableModel: DayTableModel, dateProfile: DateProfile, dateEnv: DateEnv): DateRange[] {\n  let ranges: DateRange[] = []\n\n  for (let date of dayTableModel.headerDates) {\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime),\n    })\n  }\n\n  return ranges\n}\n","import {\n  createDuration,\n  asRoughMs,\n  formatIsoTimeString,\n  addDurations,\n  wholeDivideDurations,\n  Duration,\n  DateMarker,\n  DateEnv,\n} from '@fullcalendar/common'\n\nexport interface TimeSlatMeta {\n  date: DateMarker\n  time: Duration\n  key: string\n  isoTimeStr: string\n  isLabeled: boolean\n}\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nconst STOCK_SUB_DURATIONS = [\n  { hours: 1 },\n  { minutes: 30 },\n  { minutes: 15 },\n  { seconds: 30 },\n  { seconds: 15 },\n]\n\nexport function buildSlatMetas(\n  slotMinTime: Duration,\n  slotMaxTime: Duration,\n  explicitLabelInterval: Duration | null,\n  slotDuration: Duration,\n  dateEnv: DateEnv,\n) {\n  let dayStart = new Date(0)\n  let slatTime = slotMinTime\n  let slatIterator = createDuration(0)\n  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration)\n  let metas: TimeSlatMeta[] = []\n\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    let date = dateEnv.add(dayStart, slatTime)\n    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null\n\n    metas.push({\n      date,\n      time: slatTime,\n      key: date.toISOString(), // we can't use the isoTimeStr for uniqueness when minTime/maxTime beyone 0h/24h\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled,\n    })\n\n    slatTime = addDurations(slatTime, slotDuration)\n    slatIterator = addDurations(slatIterator, slotDuration)\n  }\n\n  return metas\n}\n\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n  let i\n  let labelInterval\n  let slotsPerLabel\n\n  // find the smallest stock label interval that results in more than one slots-per-label\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i])\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration)\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval\n    }\n  }\n\n  return slotDuration // fall back\n}\n","import {\n  createElement,\n  DateProfileGenerator, DateProfile,\n  DayHeader,\n  DaySeriesModel,\n  DayTableModel,\n  memoize,\n  ChunkContentCallbackArgs,\n} from '@fullcalendar/common'\nimport { DayTable } from '@fullcalendar/daygrid'\nimport { TimeColsView } from './TimeColsView'\nimport { DayTimeCols } from './DayTimeCols'\nimport { buildSlatMetas } from './time-slat-meta'\n\nexport class DayTimeColsView extends TimeColsView {\n  private buildTimeColsModel = memoize(buildTimeColsModel)\n  private buildSlatMetas = memoize(buildSlatMetas)\n\n  render() {\n    let { options, dateEnv, dateProfileGenerator } = this.context\n    let { props } = this\n    let { dateProfile } = props\n    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator)\n    let splitProps = this.allDaySplitter.splitProps(props)\n    let slatMetas = this.buildSlatMetas(\n      dateProfile.slotMinTime,\n      dateProfile.slotMaxTime,\n      options.slotLabelInterval,\n      options.slotDuration,\n      dateEnv,\n    )\n    let { dayMinWidth } = options\n    let hasAttachedAxis = !dayMinWidth\n    let hasDetachedAxis = dayMinWidth\n\n    let headerContent = options.dayHeaders && (\n      <DayHeader\n        dates={dayTableModel.headerDates}\n        dateProfile={dateProfile}\n        datesRepDistinctDays\n        renderIntro={hasAttachedAxis ? this.renderHeadAxis : null}\n      />\n    )\n\n    let allDayContent = (options.allDaySlot !== false) && ((contentArg: ChunkContentCallbackArgs) => (\n      <DayTable\n        {...splitProps.allDay}\n        dateProfile={dateProfile}\n        dayTableModel={dayTableModel}\n        nextDayThreshold={options.nextDayThreshold}\n        tableMinWidth={contentArg.tableMinWidth}\n        colGroupNode={contentArg.tableColGroupNode}\n        renderRowIntro={hasAttachedAxis ? this.renderTableRowAxis : null}\n        showWeekNumbers={false}\n        expandRows={false}\n        headerAlignElRef={this.headerElRef}\n        clientWidth={contentArg.clientWidth}\n        clientHeight={contentArg.clientHeight}\n        forPrint={props.forPrint}\n        {...this.getAllDayMaxEventProps()}\n      />\n    ))\n\n    let timeGridContent = (contentArg: ChunkContentCallbackArgs) => (\n      <DayTimeCols\n        {...splitProps.timed}\n        dayTableModel={dayTableModel}\n        dateProfile={dateProfile}\n        axis={hasAttachedAxis}\n        slotDuration={options.slotDuration}\n        slatMetas={slatMetas}\n        forPrint={props.forPrint}\n        tableColGroupNode={contentArg.tableColGroupNode}\n        tableMinWidth={contentArg.tableMinWidth}\n        clientWidth={contentArg.clientWidth}\n        clientHeight={contentArg.clientHeight}\n        onSlatCoords={this.handleSlatCoords}\n        expandRows={contentArg.expandRows}\n        onScrollTopRequest={this.handleScrollTopRequest}\n      />\n    )\n\n    return hasDetachedAxis\n      ? this.renderHScrollLayout(\n        headerContent,\n        allDayContent,\n        timeGridContent,\n        dayTableModel.colCnt,\n        dayMinWidth,\n        slatMetas,\n        this.state.slatCoords,\n      )\n      : this.renderSimpleLayout(\n        headerContent,\n        allDayContent,\n        timeGridContent,\n      )\n  }\n}\n\nexport function buildTimeColsModel(dateProfile: DateProfile, dateProfileGenerator: DateProfileGenerator) {\n  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator)\n\n  return new DayTableModel(daySeries, false)\n}\n","import { identity, Identity, EventDropArg } from '@fullcalendar/common'\n\n// public\nimport {\n  DateClickArg,\n  EventDragStartArg, EventDragStopArg,\n  EventResizeStartArg, EventResizeStopArg, EventResizeDoneArg,\n  DropArg, EventReceiveArg, EventLeaveArg,\n} from './api-type-deps'\n\nexport const OPTION_REFINERS = {\n  fixedMirrorParent: identity as Identity<HTMLElement>,\n}\n\nexport const LISTENER_REFINERS = {\n  dateClick: identity as Identity<(arg: DateClickArg) => void>,\n  eventDragStart: identity as Identity<(arg: EventDragStartArg) => void>,\n  eventDragStop: identity as Identity<(arg: EventDragStopArg) => void>,\n  eventDrop: identity as Identity<(arg: EventDropArg) => void>,\n  eventResizeStart: identity as Identity<(arg: EventResizeStartArg) => void>,\n  eventResizeStop: identity as Identity<(arg: EventResizeStopArg) => void>,\n  eventResize: identity as Identity<(arg: EventResizeDoneArg) => void>,\n  drop: identity as Identity<(arg: DropArg) => void>,\n  eventReceive: identity as Identity<(arg: EventReceiveArg) => void>,\n  eventLeave: identity as Identity<(arg: EventLeaveArg) => void>,\n}\n","import { createPlugin } from '@fullcalendar/common'\nimport { DateClicking } from './interactions/DateClicking'\nimport { DateSelecting } from './interactions/DateSelecting'\nimport { EventDragging } from './interactions/EventDragging'\nimport { EventResizing } from './interactions/EventResizing'\nimport { UnselectAuto } from './interactions/UnselectAuto'\nimport { FeaturefulElementDragging } from './dnd/FeaturefulElementDragging'\nimport { OPTION_REFINERS, LISTENER_REFINERS } from './options'\nimport './options-declare'\n\nexport default createPlugin({\n  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],\n  calendarInteractions: [UnselectAuto],\n  elementDraggingImpl: FeaturefulElementDragging,\n  optionRefiners: OPTION_REFINERS,\n  listenerRefiners: LISTENER_REFINERS,\n})\n\nexport * from './api-type-deps'\nexport { FeaturefulElementDragging }\nexport { PointerDragging } from './dnd/PointerDragging'\nexport { ExternalDraggable as Draggable } from './interactions-external/ExternalDraggable'\nexport { ThirdPartyDraggable } from './interactions-external/ThirdPartyDraggable'\n","import { config, elementClosest, Emitter, PointerDragEvent } from '@fullcalendar/common'\n\nconfig.touchMouseIgnoreWait = 500\n\nlet ignoreMouseDepth = 0\nlet listenerCnt = 0\nlet isWindowTouchMoveCancelled = false\n\n/*\nUses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\nTracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\nAlso, tracks if there was touch-scrolling.\nAlso, can prevent touch-scrolling from happening.\nAlso, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\nemits:\n- pointerdown\n- pointermove\n- pointerup\n*/\nexport class PointerDragging {\n  containerEl: EventTarget\n  subjectEl: HTMLElement | null = null\n  emitter: Emitter<any>\n\n  // options that can be directly assigned by caller\n  selector: string = '' // will cause subjectEl in all emitted events to be this element\n  handleSelector: string = ''\n  shouldIgnoreMove: boolean = false\n  shouldWatchScroll: boolean = true // for simulating pointermove on scroll\n\n  // internal states\n  isDragging: boolean = false\n  isTouchDragging: boolean = false\n  wasTouchScroll: boolean = false\n  origPageX: number\n  origPageY: number\n  prevPageX: number\n  prevPageY: number\n  prevScrollX: number // at time of last pointer pageX/pageY capture\n  prevScrollY: number // \"\n\n  constructor(containerEl: EventTarget) {\n    this.containerEl = containerEl\n    this.emitter = new Emitter()\n    containerEl.addEventListener('mousedown', this.handleMouseDown as EventListener)\n    containerEl.addEventListener('touchstart', this.handleTouchStart as EventListener, { passive: true })\n    listenerCreated()\n  }\n\n  destroy() {\n    this.containerEl.removeEventListener('mousedown', this.handleMouseDown as EventListener)\n    this.containerEl.removeEventListener('touchstart', this.handleTouchStart as EventListener, { passive: true } as AddEventListenerOptions)\n    listenerDestroyed()\n  }\n\n  tryStart(ev: UIEvent): boolean {\n    let subjectEl = this.querySubjectEl(ev)\n    let downEl = ev.target as HTMLElement\n\n    if (\n      subjectEl &&\n      (!this.handleSelector || elementClosest(downEl, this.handleSelector))\n    ) {\n      this.subjectEl = subjectEl\n      this.isDragging = true // do this first so cancelTouchScroll will work\n      this.wasTouchScroll = false\n\n      return true\n    }\n\n    return false\n  }\n\n  cleanup() {\n    isWindowTouchMoveCancelled = false\n    this.isDragging = false\n    this.subjectEl = null\n    // keep wasTouchScroll around for later access\n    this.destroyScrollWatch()\n  }\n\n  querySubjectEl(ev: UIEvent): HTMLElement {\n    if (this.selector) {\n      return elementClosest(ev.target as HTMLElement, this.selector)\n    }\n    return this.containerEl as HTMLElement\n  }\n\n  // Mouse\n  // ----------------------------------------------------------------------------------------------------\n\n  handleMouseDown = (ev: MouseEvent) => {\n    if (\n      !this.shouldIgnoreMouse() &&\n      isPrimaryMouseButton(ev) &&\n      this.tryStart(ev)\n    ) {\n      let pev = this.createEventFromMouse(ev, true)\n      this.emitter.trigger('pointerdown', pev)\n      this.initScrollWatch(pev)\n\n      if (!this.shouldIgnoreMove) {\n        document.addEventListener('mousemove', this.handleMouseMove)\n      }\n\n      document.addEventListener('mouseup', this.handleMouseUp)\n    }\n  }\n\n  handleMouseMove = (ev: MouseEvent) => {\n    let pev = this.createEventFromMouse(ev)\n    this.recordCoords(pev)\n    this.emitter.trigger('pointermove', pev)\n  }\n\n  handleMouseUp = (ev: MouseEvent) => {\n    document.removeEventListener('mousemove', this.handleMouseMove)\n    document.removeEventListener('mouseup', this.handleMouseUp)\n\n    this.emitter.trigger('pointerup', this.createEventFromMouse(ev))\n\n    this.cleanup() // call last so that pointerup has access to props\n  }\n\n  shouldIgnoreMouse() {\n    return ignoreMouseDepth || this.isTouchDragging\n  }\n\n  // Touch\n  // ----------------------------------------------------------------------------------------------------\n\n  handleTouchStart = (ev: TouchEvent) => {\n    if (this.tryStart(ev)) {\n      this.isTouchDragging = true\n\n      let pev = this.createEventFromTouch(ev, true)\n      this.emitter.trigger('pointerdown', pev)\n      this.initScrollWatch(pev)\n\n      // unlike mouse, need to attach to target, not document\n      // https://stackoverflow.com/a/45760014\n      let targetEl = ev.target as HTMLElement\n\n      if (!this.shouldIgnoreMove) {\n        targetEl.addEventListener('touchmove', this.handleTouchMove)\n      }\n\n      targetEl.addEventListener('touchend', this.handleTouchEnd)\n      targetEl.addEventListener('touchcancel', this.handleTouchEnd) // treat it as a touch end\n\n      // attach a handler to get called when ANY scroll action happens on the page.\n      // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n      // http://stackoverflow.com/a/32954565/96342\n      window.addEventListener(\n        'scroll',\n        this.handleTouchScroll,\n        true, // useCapture\n      )\n    }\n  }\n\n  handleTouchMove = (ev: TouchEvent) => {\n    let pev = this.createEventFromTouch(ev)\n    this.recordCoords(pev)\n    this.emitter.trigger('pointermove', pev)\n  }\n\n  handleTouchEnd = (ev: TouchEvent) => {\n    if (this.isDragging) { // done to guard against touchend followed by touchcancel\n      let targetEl = ev.target as HTMLElement\n\n      targetEl.removeEventListener('touchmove', this.handleTouchMove)\n      targetEl.removeEventListener('touchend', this.handleTouchEnd)\n      targetEl.removeEventListener('touchcancel', this.handleTouchEnd)\n      window.removeEventListener('scroll', this.handleTouchScroll, true) // useCaptured=true\n\n      this.emitter.trigger('pointerup', this.createEventFromTouch(ev))\n\n      this.cleanup() // call last so that pointerup has access to props\n      this.isTouchDragging = false\n      startIgnoringMouse()\n    }\n  }\n\n  handleTouchScroll = () => {\n    this.wasTouchScroll = true\n  }\n\n  // can be called by user of this class, to cancel touch-based scrolling for the current drag\n  cancelTouchScroll() {\n    if (this.isDragging) {\n      isWindowTouchMoveCancelled = true\n    }\n  }\n\n  // Scrolling that simulates pointermoves\n  // ----------------------------------------------------------------------------------------------------\n\n  initScrollWatch(ev: PointerDragEvent) {\n    if (this.shouldWatchScroll) {\n      this.recordCoords(ev)\n      window.addEventListener('scroll', this.handleScroll, true) // useCapture=true\n    }\n  }\n\n  recordCoords(ev: PointerDragEvent) {\n    if (this.shouldWatchScroll) {\n      this.prevPageX = (ev as any).pageX\n      this.prevPageY = (ev as any).pageY\n      this.prevScrollX = window.pageXOffset\n      this.prevScrollY = window.pageYOffset\n    }\n  }\n\n  handleScroll = (ev: UIEvent) => {\n    if (!this.shouldIgnoreMove) {\n      let pageX = (window.pageXOffset - this.prevScrollX) + this.prevPageX\n      let pageY = (window.pageYOffset - this.prevScrollY) + this.prevPageY\n\n      this.emitter.trigger('pointermove', {\n        origEvent: ev,\n        isTouch: this.isTouchDragging,\n        subjectEl: this.subjectEl,\n        pageX,\n        pageY,\n        deltaX: pageX - this.origPageX,\n        deltaY: pageY - this.origPageY,\n      } as PointerDragEvent)\n    }\n  }\n\n  destroyScrollWatch() {\n    if (this.shouldWatchScroll) {\n      window.removeEventListener('scroll', this.handleScroll, true) // useCaptured=true\n    }\n  }\n\n  // Event Normalization\n  // ----------------------------------------------------------------------------------------------------\n\n  createEventFromMouse(ev: MouseEvent, isFirst?: boolean): PointerDragEvent {\n    let deltaX = 0\n    let deltaY = 0\n\n    // TODO: repeat code\n    if (isFirst) {\n      this.origPageX = ev.pageX\n      this.origPageY = ev.pageY\n    } else {\n      deltaX = ev.pageX - this.origPageX\n      deltaY = ev.pageY - this.origPageY\n    }\n\n    return {\n      origEvent: ev,\n      isTouch: false,\n      subjectEl: this.subjectEl,\n      pageX: ev.pageX,\n      pageY: ev.pageY,\n      deltaX,\n      deltaY,\n    }\n  }\n\n  createEventFromTouch(ev: TouchEvent, isFirst?: boolean): PointerDragEvent {\n    let touches = ev.touches\n    let pageX\n    let pageY\n    let deltaX = 0\n    let deltaY = 0\n\n    // if touch coords available, prefer,\n    // because FF would give bad ev.pageX ev.pageY\n    if (touches && touches.length) {\n      pageX = touches[0].pageX\n      pageY = touches[0].pageY\n    } else {\n      pageX = (ev as any).pageX\n      pageY = (ev as any).pageY\n    }\n\n    // TODO: repeat code\n    if (isFirst) {\n      this.origPageX = pageX\n      this.origPageY = pageY\n    } else {\n      deltaX = pageX - this.origPageX\n      deltaY = pageY - this.origPageY\n    }\n\n    return {\n      origEvent: ev,\n      isTouch: true,\n      subjectEl: this.subjectEl,\n      pageX,\n      pageY,\n      deltaX,\n      deltaY,\n    }\n  }\n}\n\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\nfunction isPrimaryMouseButton(ev: MouseEvent) {\n  return ev.button === 0 && !ev.ctrlKey\n}\n\n// Ignoring fake mouse events generated by touch\n// ----------------------------------------------------------------------------------------------------\n\nfunction startIgnoringMouse() { // can be made non-class function\n  ignoreMouseDepth += 1\n\n  setTimeout(() => {\n    ignoreMouseDepth -= 1\n  }, config.touchMouseIgnoreWait)\n}\n\n// We want to attach touchmove as early as possible for Safari\n// ----------------------------------------------------------------------------------------------------\n\nfunction listenerCreated() {\n  listenerCnt += 1\n\n  if (listenerCnt === 1) {\n    window.addEventListener('touchmove', onWindowTouchMove, { passive: false })\n  }\n}\n\nfunction listenerDestroyed() {\n  listenerCnt -= 1\n\n  if (!listenerCnt) {\n    window.removeEventListener('touchmove', onWindowTouchMove, { passive: false } as AddEventListenerOptions)\n  }\n}\n\nfunction onWindowTouchMove(ev: UIEvent) {\n  if (isWindowTouchMoveCancelled) {\n    ev.preventDefault()\n  }\n}\n","import { removeElement, applyStyle, whenTransitionDone, Rect } from '@fullcalendar/common'\n\n/*\nAn effect in which an element follows the movement of a pointer across the screen.\nThe moving element is a clone of some other element.\nMust call start + handleMove + stop.\n*/\nexport class ElementMirror {\n  isVisible: boolean = false // must be explicitly enabled\n  origScreenX?: number\n  origScreenY?: number\n  deltaX?: number\n  deltaY?: number\n  sourceEl: HTMLElement | null = null\n  mirrorEl: HTMLElement | null = null\n  sourceElRect: Rect | null = null // screen coords relative to viewport\n\n  // options that can be set directly by caller\n  parentNode: HTMLElement = document.body // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n  zIndex: number = 9999\n  revertDuration: number = 0\n\n  start(sourceEl: HTMLElement, pageX: number, pageY: number) {\n    this.sourceEl = sourceEl\n    this.sourceElRect = this.sourceEl.getBoundingClientRect()\n    this.origScreenX = pageX - window.pageXOffset\n    this.origScreenY = pageY - window.pageYOffset\n    this.deltaX = 0\n    this.deltaY = 0\n    this.updateElPosition()\n  }\n\n  handleMove(pageX: number, pageY: number) {\n    this.deltaX = (pageX - window.pageXOffset) - this.origScreenX!\n    this.deltaY = (pageY - window.pageYOffset) - this.origScreenY!\n    this.updateElPosition()\n  }\n\n  // can be called before start\n  setIsVisible(bool: boolean) {\n    if (bool) {\n      if (!this.isVisible) {\n        if (this.mirrorEl) {\n          this.mirrorEl.style.display = ''\n        }\n\n        this.isVisible = bool // needs to happen before updateElPosition\n        this.updateElPosition() // because was not updating the position while invisible\n      }\n    } else if (this.isVisible) {\n      if (this.mirrorEl) {\n        this.mirrorEl.style.display = 'none'\n      }\n\n      this.isVisible = bool\n    }\n  }\n\n  // always async\n  stop(needsRevertAnimation: boolean, callback: () => void) {\n    let done = () => {\n      this.cleanup()\n      callback()\n    }\n\n    if (\n      needsRevertAnimation &&\n      this.mirrorEl &&\n      this.isVisible &&\n      this.revertDuration && // if 0, transition won't work\n      (this.deltaX || this.deltaY) // if same coords, transition won't work\n    ) {\n      this.doRevertAnimation(done, this.revertDuration)\n    } else {\n      setTimeout(done, 0)\n    }\n  }\n\n  doRevertAnimation(callback: () => void, revertDuration: number) {\n    let mirrorEl = this.mirrorEl!\n    let finalSourceElRect = this.sourceEl!.getBoundingClientRect() // because autoscrolling might have happened\n\n    mirrorEl.style.transition =\n      'top ' + revertDuration + 'ms,' +\n      'left ' + revertDuration + 'ms'\n\n    applyStyle(mirrorEl, {\n      left: finalSourceElRect.left,\n      top: finalSourceElRect.top,\n    })\n\n    whenTransitionDone(mirrorEl, () => {\n      mirrorEl.style.transition = ''\n      callback()\n    })\n  }\n\n  cleanup() {\n    if (this.mirrorEl) {\n      removeElement(this.mirrorEl)\n      this.mirrorEl = null\n    }\n\n    this.sourceEl = null\n  }\n\n  updateElPosition() {\n    if (this.sourceEl && this.isVisible) {\n      applyStyle(this.getMirrorEl(), {\n        left: this.sourceElRect!.left + this.deltaX!,\n        top: this.sourceElRect!.top + this.deltaY!,\n      })\n    }\n  }\n\n  getMirrorEl(): HTMLElement {\n    let sourceElRect = this.sourceElRect!\n    let mirrorEl = this.mirrorEl\n\n    if (!mirrorEl) {\n      mirrorEl = this.mirrorEl = this.sourceEl!.cloneNode(true) as HTMLElement // cloneChildren=true\n\n      // we don't want long taps or any mouse interaction causing selection/menus.\n      // would use preventSelection(), but that prevents selectstart, causing problems.\n      mirrorEl.classList.add('fc-unselectable')\n\n      mirrorEl.classList.add('fc-event-dragging')\n\n      applyStyle(mirrorEl, {\n        position: 'fixed',\n        zIndex: this.zIndex,\n        visibility: '', // in case original element was hidden by the drag effect\n        boxSizing: 'border-box', // for easy width/height\n        width: sourceElRect.right - sourceElRect.left, // explicit height in case there was a 'right' value\n        height: sourceElRect.bottom - sourceElRect.top, // explicit width in case there was a 'bottom' value\n        right: 'auto', // erase and set width instead\n        bottom: 'auto', // erase and set height instead\n        margin: 0,\n      })\n\n      this.parentNode.appendChild(mirrorEl)\n    }\n\n    return mirrorEl\n  }\n}\n","import { Rect, ScrollController } from '@fullcalendar/common'\n\n/*\nIs a cache for a given element's scroll information (all the info that ScrollController stores)\nin addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\nThe cache can be in one of two modes:\n- doesListening:false - ignores when the container is scrolled by someone else\n- doesListening:true - watch for scrolling and update the cache\n*/\nexport abstract class ScrollGeomCache extends ScrollController {\n  clientRect: Rect\n  origScrollTop: number\n  origScrollLeft: number\n\n  protected scrollController: ScrollController\n  protected doesListening: boolean\n  protected scrollTop: number\n  protected scrollLeft: number\n  protected scrollWidth: number\n  protected scrollHeight: number\n  protected clientWidth: number\n  protected clientHeight: number\n\n  constructor(scrollController: ScrollController, doesListening: boolean) {\n    super()\n    this.scrollController = scrollController\n    this.doesListening = doesListening\n    this.scrollTop = this.origScrollTop = scrollController.getScrollTop()\n    this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft()\n    this.scrollWidth = scrollController.getScrollWidth()\n    this.scrollHeight = scrollController.getScrollHeight()\n    this.clientWidth = scrollController.getClientWidth()\n    this.clientHeight = scrollController.getClientHeight()\n    this.clientRect = this.computeClientRect() // do last in case it needs cached values\n\n    if (this.doesListening) {\n      this.getEventTarget().addEventListener('scroll', this.handleScroll)\n    }\n  }\n\n  abstract getEventTarget(): EventTarget\n  abstract computeClientRect(): Rect\n\n  destroy() {\n    if (this.doesListening) {\n      this.getEventTarget().removeEventListener('scroll', this.handleScroll)\n    }\n  }\n\n  handleScroll = () => {\n    this.scrollTop = this.scrollController.getScrollTop()\n    this.scrollLeft = this.scrollController.getScrollLeft()\n    this.handleScrollChange()\n  }\n\n  getScrollTop() {\n    return this.scrollTop\n  }\n\n  getScrollLeft() {\n    return this.scrollLeft\n  }\n\n  setScrollTop(top: number) {\n    this.scrollController.setScrollTop(top)\n\n    if (!this.doesListening) {\n      // we are not relying on the element to normalize out-of-bounds scroll values\n      // so we need to sanitize ourselves\n      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0)\n\n      this.handleScrollChange()\n    }\n  }\n\n  setScrollLeft(top: number) {\n    this.scrollController.setScrollLeft(top)\n\n    if (!this.doesListening) {\n      // we are not relying on the element to normalize out-of-bounds scroll values\n      // so we need to sanitize ourselves\n      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0)\n\n      this.handleScrollChange()\n    }\n  }\n\n  getClientWidth() {\n    return this.clientWidth\n  }\n\n  getClientHeight() {\n    return this.clientHeight\n  }\n\n  getScrollWidth() {\n    return this.scrollWidth\n  }\n\n  getScrollHeight() {\n    return this.scrollHeight\n  }\n\n  handleScrollChange() {\n  }\n}\n","import { computeInnerRect, ElementScrollController } from '@fullcalendar/common'\nimport { ScrollGeomCache } from './ScrollGeomCache'\n\nexport class ElementScrollGeomCache extends ScrollGeomCache {\n  constructor(el: HTMLElement, doesListening: boolean) {\n    super(new ElementScrollController(el), doesListening)\n  }\n\n  getEventTarget(): EventTarget {\n    return (this.scrollController as ElementScrollController).el\n  }\n\n  computeClientRect() {\n    return computeInnerRect((this.scrollController as ElementScrollController).el)\n  }\n}\n","import { Rect, WindowScrollController } from '@fullcalendar/common'\nimport { ScrollGeomCache } from './ScrollGeomCache'\n\nexport class WindowScrollGeomCache extends ScrollGeomCache {\n  constructor(doesListening: boolean) {\n    super(new WindowScrollController(), doesListening)\n  }\n\n  getEventTarget(): EventTarget {\n    return window\n  }\n\n  computeClientRect(): Rect {\n    return {\n      left: this.scrollLeft,\n      right: this.scrollLeft + this.clientWidth,\n      top: this.scrollTop,\n      bottom: this.scrollTop + this.clientHeight,\n    }\n  }\n\n  // the window is the only scroll object that changes it's rectangle relative\n  // to the document's topleft as it scrolls\n  handleScrollChange() {\n    this.clientRect = this.computeClientRect()\n  }\n}\n","import { getElRoot } from '@fullcalendar/common'\nimport { ScrollGeomCache } from '../ScrollGeomCache'\nimport { ElementScrollGeomCache } from '../ElementScrollGeomCache'\nimport { WindowScrollGeomCache } from '../WindowScrollGeomCache'\n\ninterface Edge {\n  scrollCache: ScrollGeomCache\n  name: 'top' | 'left' | 'right' | 'bottom'\n  distance: number // how many pixels the current pointer is from the edge\n}\n\n// If available we are using native \"performance\" API instead of \"Date\"\n// Read more about it on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/Performance\nconst getTime = typeof performance === 'function' ? (performance as any).now : Date.now\n\n/*\nFor a pointer interaction, automatically scrolls certain scroll containers when the pointer\napproaches the edge.\n\nThe caller must call start + handleMove + stop.\n*/\nexport class AutoScroller {\n  // options that can be set by caller\n  isEnabled: boolean = true\n  scrollQuery: (Window | string)[] = [window, '.fc-scroller']\n  edgeThreshold: number = 50 // pixels\n  maxVelocity: number = 300 // pixels per second\n\n  // internal state\n  pointerScreenX: number | null = null\n  pointerScreenY: number | null = null\n  isAnimating: boolean = false\n  scrollCaches: ScrollGeomCache[] | null = null\n  msSinceRequest?: number\n\n  // protect against the initial pointerdown being too close to an edge and starting the scroll\n  everMovedUp: boolean = false\n  everMovedDown: boolean = false\n  everMovedLeft: boolean = false\n  everMovedRight: boolean = false\n\n  start(pageX: number, pageY: number, scrollStartEl: HTMLElement) {\n    if (this.isEnabled) {\n      this.scrollCaches = this.buildCaches(scrollStartEl)\n      this.pointerScreenX = null\n      this.pointerScreenY = null\n      this.everMovedUp = false\n      this.everMovedDown = false\n      this.everMovedLeft = false\n      this.everMovedRight = false\n      this.handleMove(pageX, pageY)\n    }\n  }\n\n  handleMove(pageX: number, pageY: number) {\n    if (this.isEnabled) {\n      let pointerScreenX = pageX - window.pageXOffset\n      let pointerScreenY = pageY - window.pageYOffset\n\n      let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY\n      let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX\n\n      if (yDelta < 0) {\n        this.everMovedUp = true\n      } else if (yDelta > 0) {\n        this.everMovedDown = true\n      }\n\n      if (xDelta < 0) {\n        this.everMovedLeft = true\n      } else if (xDelta > 0) {\n        this.everMovedRight = true\n      }\n\n      this.pointerScreenX = pointerScreenX\n      this.pointerScreenY = pointerScreenY\n\n      if (!this.isAnimating) {\n        this.isAnimating = true\n        this.requestAnimation(getTime())\n      }\n    }\n  }\n\n  stop() {\n    if (this.isEnabled) {\n      this.isAnimating = false // will stop animation\n\n      for (let scrollCache of this.scrollCaches!) {\n        scrollCache.destroy()\n      }\n\n      this.scrollCaches = null\n    }\n  }\n\n  requestAnimation(now: number) {\n    this.msSinceRequest = now\n    requestAnimationFrame(this.animate)\n  }\n\n  private animate = () => {\n    if (this.isAnimating) { // wasn't cancelled between animation calls\n      let edge = this.computeBestEdge(\n        this.pointerScreenX! + window.pageXOffset,\n        this.pointerScreenY! + window.pageYOffset,\n      )\n\n      if (edge) {\n        let now = getTime()\n        this.handleSide(edge, (now - this.msSinceRequest!) / 1000)\n        this.requestAnimation(now)\n      } else {\n        this.isAnimating = false // will stop animation\n      }\n    }\n  }\n\n  private handleSide(edge: Edge, seconds: number) {\n    let { scrollCache } = edge\n    let { edgeThreshold } = this\n    let invDistance = edgeThreshold - edge.distance\n    let velocity = // the closer to the edge, the faster we scroll\n      ((invDistance * invDistance) / (edgeThreshold * edgeThreshold)) * // quadratic\n      this.maxVelocity * seconds\n    let sign = 1\n\n    switch (edge.name) {\n      case 'left':\n        sign = -1\n        // falls through\n      case 'right':\n        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign)\n        break\n\n      case 'top':\n        sign = -1\n        // falls through\n      case 'bottom':\n        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign)\n        break\n    }\n  }\n\n  // left/top are relative to document topleft\n  private computeBestEdge(left: number, top: number): Edge | null {\n    let { edgeThreshold } = this\n    let bestSide: Edge | null = null\n\n    for (let scrollCache of this.scrollCaches!) {\n      let rect = scrollCache.clientRect\n      let leftDist = left - rect.left\n      let rightDist = rect.right - left\n      let topDist = top - rect.top\n      let bottomDist = rect.bottom - top\n\n      // completely within the rect?\n      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n        if (\n          topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() &&\n          (!bestSide || bestSide.distance > topDist)\n        ) {\n          bestSide = { scrollCache, name: 'top', distance: topDist }\n        }\n\n        if (\n          bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() &&\n          (!bestSide || bestSide.distance > bottomDist)\n        ) {\n          bestSide = { scrollCache, name: 'bottom', distance: bottomDist }\n        }\n\n        if (\n          leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() &&\n          (!bestSide || bestSide.distance > leftDist)\n        ) {\n          bestSide = { scrollCache, name: 'left', distance: leftDist }\n        }\n\n        if (\n          rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() &&\n          (!bestSide || bestSide.distance > rightDist)\n        ) {\n          bestSide = { scrollCache, name: 'right', distance: rightDist }\n        }\n      }\n    }\n\n    return bestSide\n  }\n\n  private buildCaches(scrollStartEl: HTMLElement) {\n    return this.queryScrollEls(scrollStartEl).map((el) => {\n      if (el === window) {\n        return new WindowScrollGeomCache(false) // false = don't listen to user-generated scrolls\n      }\n      return new ElementScrollGeomCache(el, false) // false = don't listen to user-generated scrolls\n    })\n  }\n\n  private queryScrollEls(scrollStartEl: HTMLElement) {\n    let els = []\n\n    for (let query of this.scrollQuery) {\n      if (typeof query === 'object') {\n        els.push(query)\n      } else {\n        els.push(...Array.prototype.slice.call(\n          getElRoot(scrollStartEl).querySelectorAll(query),\n        ))\n      }\n    }\n\n    return els\n  }\n}\n","import {\n  PointerDragEvent,\n  preventSelection,\n  allowSelection,\n  preventContextMenu,\n  allowContextMenu,\n  ElementDragging,\n} from '@fullcalendar/common'\nimport { PointerDragging } from './PointerDragging'\nimport { ElementMirror } from './ElementMirror'\nimport { AutoScroller } from './AutoScroller'\n\n/*\nMonitors dragging on an element. Has a number of high-level features:\n- minimum distance required before dragging\n- minimum wait time (\"delay\") before dragging\n- a mirror element that follows the pointer\n*/\nexport class FeaturefulElementDragging extends ElementDragging {\n  pointer: PointerDragging\n  mirror: ElementMirror\n  autoScroller: AutoScroller\n\n  // options that can be directly set by caller\n  // the caller can also set the PointerDragging's options as well\n  delay: number | null = null\n  minDistance: number = 0\n  touchScrollAllowed: boolean = true // prevents drag from starting and blocks scrolling during drag\n\n  mirrorNeedsRevert: boolean = false\n  isInteracting: boolean = false // is the user validly moving the pointer? lasts until pointerup\n  isDragging: boolean = false // is it INTENTFULLY dragging? lasts until after revert animation\n  isDelayEnded: boolean = false\n  isDistanceSurpassed: boolean = false\n  delayTimeoutId: number | null = null\n\n  constructor(private containerEl: HTMLElement, selector?: string) {\n    super(containerEl)\n\n    let pointer = this.pointer = new PointerDragging(containerEl)\n    pointer.emitter.on('pointerdown', this.onPointerDown)\n    pointer.emitter.on('pointermove', this.onPointerMove)\n    pointer.emitter.on('pointerup', this.onPointerUp)\n\n    if (selector) {\n      pointer.selector = selector\n    }\n\n    this.mirror = new ElementMirror()\n    this.autoScroller = new AutoScroller()\n  }\n\n  destroy() {\n    this.pointer.destroy()\n\n    // HACK: simulate a pointer-up to end the current drag\n    // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n    this.onPointerUp({} as any)\n  }\n\n  onPointerDown = (ev: PointerDragEvent) => {\n    if (!this.isDragging) { // so new drag doesn't happen while revert animation is going\n      this.isInteracting = true\n      this.isDelayEnded = false\n      this.isDistanceSurpassed = false\n\n      preventSelection(document.body)\n      preventContextMenu(document.body)\n\n      // prevent links from being visited if there's an eventual drag.\n      // also prevents selection in older browsers (maybe?).\n      // not necessary for touch, besides, browser would complain about passiveness.\n      if (!ev.isTouch) {\n        ev.origEvent.preventDefault()\n      }\n\n      this.emitter.trigger('pointerdown', ev)\n\n      if (\n        this.isInteracting && // not destroyed via pointerdown handler\n        !this.pointer.shouldIgnoreMove\n      ) {\n        // actions related to initiating dragstart+dragmove+dragend...\n\n        this.mirror.setIsVisible(false) // reset. caller must set-visible\n        this.mirror.start(ev.subjectEl as HTMLElement, ev.pageX, ev.pageY) // must happen on first pointer down\n\n        this.startDelay(ev)\n\n        if (!this.minDistance) {\n          this.handleDistanceSurpassed(ev)\n        }\n      }\n    }\n  }\n\n  onPointerMove = (ev: PointerDragEvent) => {\n    if (this.isInteracting) {\n      this.emitter.trigger('pointermove', ev)\n\n      if (!this.isDistanceSurpassed) {\n        let minDistance = this.minDistance\n        let distanceSq // current distance from the origin, squared\n        let { deltaX, deltaY } = ev\n\n        distanceSq = deltaX * deltaX + deltaY * deltaY\n        if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem\n          this.handleDistanceSurpassed(ev)\n        }\n      }\n\n      if (this.isDragging) {\n        // a real pointer move? (not one simulated by scrolling)\n        if (ev.origEvent.type !== 'scroll') {\n          this.mirror.handleMove(ev.pageX, ev.pageY)\n          this.autoScroller.handleMove(ev.pageX, ev.pageY)\n        }\n\n        this.emitter.trigger('dragmove', ev)\n      }\n    }\n  }\n\n  onPointerUp = (ev: PointerDragEvent) => {\n    if (this.isInteracting) {\n      this.isInteracting = false\n\n      allowSelection(document.body)\n      allowContextMenu(document.body)\n\n      this.emitter.trigger('pointerup', ev) // can potentially set mirrorNeedsRevert\n\n      if (this.isDragging) {\n        this.autoScroller.stop()\n        this.tryStopDrag(ev) // which will stop the mirror\n      }\n\n      if (this.delayTimeoutId) {\n        clearTimeout(this.delayTimeoutId)\n        this.delayTimeoutId = null\n      }\n    }\n  }\n\n  startDelay(ev: PointerDragEvent) {\n    if (typeof this.delay === 'number') {\n      this.delayTimeoutId = setTimeout(() => {\n        this.delayTimeoutId = null\n        this.handleDelayEnd(ev)\n      }, this.delay) as any // not assignable to number!\n    } else {\n      this.handleDelayEnd(ev)\n    }\n  }\n\n  handleDelayEnd(ev: PointerDragEvent) {\n    this.isDelayEnded = true\n    this.tryStartDrag(ev)\n  }\n\n  handleDistanceSurpassed(ev: PointerDragEvent) {\n    this.isDistanceSurpassed = true\n    this.tryStartDrag(ev)\n  }\n\n  tryStartDrag(ev: PointerDragEvent) {\n    if (this.isDelayEnded && this.isDistanceSurpassed) {\n      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n        this.isDragging = true\n        this.mirrorNeedsRevert = false\n\n        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl)\n        this.emitter.trigger('dragstart', ev)\n\n        if (this.touchScrollAllowed === false) {\n          this.pointer.cancelTouchScroll()\n        }\n      }\n    }\n  }\n\n  tryStopDrag(ev: PointerDragEvent) {\n    // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n    // that come from the document to fire beforehand. much more convenient this way.\n    this.mirror.stop(\n      this.mirrorNeedsRevert,\n      this.stopDrag.bind(this, ev), // bound with args\n    )\n  }\n\n  stopDrag(ev: PointerDragEvent) {\n    this.isDragging = false\n    this.emitter.trigger('dragend', ev)\n  }\n\n  // fill in the implementations...\n\n  setIgnoreMove(bool: boolean) {\n    this.pointer.shouldIgnoreMove = bool\n  }\n\n  setMirrorIsVisible(bool: boolean) {\n    this.mirror.setIsVisible(bool)\n  }\n\n  setMirrorNeedsRevert(bool: boolean) {\n    this.mirrorNeedsRevert = bool\n  }\n\n  setAutoScrollEnabled(bool: boolean) {\n    this.autoScroller.isEnabled = bool\n  }\n}\n","import {\n  getClippingParents, computeRect,\n  pointInsideRect, Rect,\n} from '@fullcalendar/common'\nimport { ElementScrollGeomCache } from './ElementScrollGeomCache'\n\n/*\nWhen this class is instantiated, it records the offset of an element (relative to the document topleft),\nand continues to monitor scrolling, updating the cached coordinates if it needs to.\nDoes not access the DOM after instantiation, so highly performant.\n\nAlso keeps track of all scrolling/overflow:hidden containers that are parents of the given element\nand an determine if a given point is inside the combined clipping rectangle.\n*/\nexport class OffsetTracker { // ElementOffsetTracker\n  scrollCaches: ElementScrollGeomCache[]\n  origRect: Rect\n\n  constructor(el: HTMLElement) {\n    this.origRect = computeRect(el)\n\n    // will work fine for divs that have overflow:hidden\n    this.scrollCaches = getClippingParents(el).map(\n      (scrollEl) => new ElementScrollGeomCache(scrollEl, true), // listen=true\n    )\n  }\n\n  destroy() {\n    for (let scrollCache of this.scrollCaches) {\n      scrollCache.destroy()\n    }\n  }\n\n  computeLeft() {\n    let left = this.origRect.left\n\n    for (let scrollCache of this.scrollCaches) {\n      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft()\n    }\n\n    return left\n  }\n\n  computeTop() {\n    let top = this.origRect.top\n\n    for (let scrollCache of this.scrollCaches) {\n      top += scrollCache.origScrollTop - scrollCache.getScrollTop()\n    }\n\n    return top\n  }\n\n  isWithinClipping(pageX: number, pageY: number): boolean {\n    let point = { left: pageX, top: pageY }\n\n    for (let scrollCache of this.scrollCaches) {\n      if (\n        !isIgnoredClipping(scrollCache.getEventTarget()) &&\n        !pointInsideRect(point, scrollCache.clientRect)\n      ) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n// certain clipping containers should never constrain interactions, like <html> and <body>\n// https://github.com/fullcalendar/fullcalendar/issues/3615\nfunction isIgnoredClipping(node: EventTarget) {\n  let tagName = (node as HTMLElement).tagName\n\n  return tagName === 'HTML' || tagName === 'BODY'\n}\n","import {\n  Emitter, PointerDragEvent,\n  isDateSpansEqual,\n  computeRect,\n  constrainPoint, intersectRects, getRectCenter, diffPoints, Point,\n  rangeContainsRange,\n  Hit,\n  InteractionSettingsStore,\n  mapHash,\n  ElementDragging,\n} from '@fullcalendar/common'\nimport { OffsetTracker } from '../OffsetTracker'\n\n/*\nTracks movement over multiple droppable areas (aka \"hits\")\nthat exist in one or more DateComponents.\nRelies on an existing draggable.\n\nemits:\n- pointerdown\n- dragstart\n- hitchange - fires initially, even if not over a hit\n- pointerup\n- (hitchange - again, to null, if ended over a hit)\n- dragend\n*/\nexport class HitDragging {\n  droppableStore: InteractionSettingsStore\n  dragging: ElementDragging\n  emitter: Emitter<any>\n\n  // options that can be set by caller\n  useSubjectCenter: boolean = false\n  requireInitial: boolean = true // if doesn't start out on a hit, won't emit any events\n\n  // internal state\n  offsetTrackers: { [componentUid: string]: OffsetTracker }\n  initialHit: Hit | null = null\n  movingHit: Hit | null = null\n  finalHit: Hit | null = null // won't ever be populated if shouldIgnoreMove\n  coordAdjust?: Point\n\n  constructor(dragging: ElementDragging, droppableStore: InteractionSettingsStore) {\n    this.droppableStore = droppableStore\n\n    dragging.emitter.on('pointerdown', this.handlePointerDown)\n    dragging.emitter.on('dragstart', this.handleDragStart)\n    dragging.emitter.on('dragmove', this.handleDragMove)\n    dragging.emitter.on('pointerup', this.handlePointerUp)\n    dragging.emitter.on('dragend', this.handleDragEnd)\n\n    this.dragging = dragging\n    this.emitter = new Emitter()\n  }\n\n  handlePointerDown = (ev: PointerDragEvent) => {\n    let { dragging } = this\n\n    this.initialHit = null\n    this.movingHit = null\n    this.finalHit = null\n\n    this.prepareHits()\n    this.processFirstCoord(ev)\n\n    if (this.initialHit || !this.requireInitial) {\n      dragging.setIgnoreMove(false)\n\n      // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n      this.emitter.trigger('pointerdown', ev)\n    } else {\n      dragging.setIgnoreMove(true)\n    }\n  }\n\n  // sets initialHit\n  // sets coordAdjust\n  processFirstCoord(ev: PointerDragEvent) {\n    let origPoint = { left: ev.pageX, top: ev.pageY }\n    let adjustedPoint = origPoint\n    let subjectEl = ev.subjectEl\n    let subjectRect\n\n    if (subjectEl instanceof HTMLElement) { // i.e. not a Document/ShadowRoot\n      subjectRect = computeRect(subjectEl)\n      adjustedPoint = constrainPoint(adjustedPoint, subjectRect)\n    }\n\n    let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top)\n    if (initialHit) {\n      if (this.useSubjectCenter && subjectRect) {\n        let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect)\n        if (slicedSubjectRect) {\n          adjustedPoint = getRectCenter(slicedSubjectRect)\n        }\n      }\n\n      this.coordAdjust = diffPoints(adjustedPoint, origPoint)\n    } else {\n      this.coordAdjust = { left: 0, top: 0 }\n    }\n  }\n\n  handleDragStart = (ev: PointerDragEvent) => {\n    this.emitter.trigger('dragstart', ev)\n    this.handleMove(ev, true) // force = fire even if initially null\n  }\n\n  handleDragMove = (ev: PointerDragEvent) => {\n    this.emitter.trigger('dragmove', ev)\n    this.handleMove(ev)\n  }\n\n  handlePointerUp = (ev: PointerDragEvent) => {\n    this.releaseHits()\n    this.emitter.trigger('pointerup', ev)\n  }\n\n  handleDragEnd = (ev: PointerDragEvent) => {\n    if (this.movingHit) {\n      this.emitter.trigger('hitupdate', null, true, ev)\n    }\n\n    this.finalHit = this.movingHit\n    this.movingHit = null\n    this.emitter.trigger('dragend', ev)\n  }\n\n  handleMove(ev: PointerDragEvent, forceHandle?: boolean) {\n    let hit = this.queryHitForOffset(\n      ev.pageX + this.coordAdjust!.left,\n      ev.pageY + this.coordAdjust!.top,\n    )\n\n    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n      this.movingHit = hit\n      this.emitter.trigger('hitupdate', hit, false, ev)\n    }\n  }\n\n  prepareHits() {\n    this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {\n      interactionSettings.component.prepareHits()\n      return new OffsetTracker(interactionSettings.el)\n    })\n  }\n\n  releaseHits() {\n    let { offsetTrackers } = this\n\n    for (let id in offsetTrackers) {\n      offsetTrackers[id].destroy()\n    }\n\n    this.offsetTrackers = {}\n  }\n\n  queryHitForOffset(offsetLeft: number, offsetTop: number): Hit | null {\n    let { droppableStore, offsetTrackers } = this\n    let bestHit: Hit | null = null\n\n    for (let id in droppableStore) {\n      let component = droppableStore[id].component\n      let offsetTracker = offsetTrackers[id]\n\n      if (\n        offsetTracker && // wasn't destroyed mid-drag\n        offsetTracker.isWithinClipping(offsetLeft, offsetTop)\n      ) {\n        let originLeft = offsetTracker.computeLeft()\n        let originTop = offsetTracker.computeTop()\n        let positionLeft = offsetLeft - originLeft\n        let positionTop = offsetTop - originTop\n        let { origRect } = offsetTracker\n        let width = origRect.right - origRect.left\n        let height = origRect.bottom - origRect.top\n\n        if (\n          // must be within the element's bounds\n          positionLeft >= 0 && positionLeft < width &&\n          positionTop >= 0 && positionTop < height\n        ) {\n          let hit = component.queryHit(positionLeft, positionTop, width, height)\n          if (\n            hit && (\n              // make sure the hit is within activeRange, meaning it's not a dead cell\n              rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range)\n            ) &&\n            (!bestHit || hit.layer > bestHit.layer)\n          ) {\n            hit.componentId = id\n            hit.context = component.context\n\n            // TODO: better way to re-orient rectangle\n            hit.rect.left += originLeft\n            hit.rect.right += originLeft\n            hit.rect.top += originTop\n            hit.rect.bottom += originTop\n\n            bestHit = hit\n          }\n        }\n      }\n    }\n\n    return bestHit\n  }\n}\n\nexport function isHitsEqual(hit0: Hit | null, hit1: Hit | null): boolean {\n  if (!hit0 && !hit1) {\n    return true\n  }\n\n  if (Boolean(hit0) !== Boolean(hit1)) {\n    return false\n  }\n\n  return isDateSpansEqual(hit0!.dateSpan, hit1!.dateSpan)\n}\n","import { DateSpan, CalendarContext, DatePointApi, DateEnv, ViewApi, EventApi } from '@fullcalendar/common'\nimport { __assign } from 'tslib'\n\nexport interface DropArg extends DatePointApi {\n  draggedEl: HTMLElement\n  jsEvent: MouseEvent\n  view: ViewApi\n}\n\nexport type EventReceiveArg = EventReceiveLeaveArg\nexport type EventLeaveArg = EventReceiveLeaveArg\nexport interface EventReceiveLeaveArg { // will this become public?\n  draggedEl: HTMLElement\n  event: EventApi\n  relatedEvents: EventApi[]\n  revert: () => void\n  view: ViewApi\n}\n\nexport function buildDatePointApiWithContext(dateSpan: DateSpan, context: CalendarContext) {\n  let props = {} as DatePointApi\n\n  for (let transform of context.pluginHooks.datePointTransforms) {\n    __assign(props, transform(dateSpan, context))\n  }\n\n  __assign(props, buildDatePointApi(dateSpan, context.dateEnv))\n\n  return props\n}\n\nexport function buildDatePointApi(span: DateSpan, dateEnv: DateEnv): DatePointApi {\n  return {\n    date: dateEnv.toDate(span.range.start),\n    dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),\n    allDay: span.allDay,\n  }\n}\n","import {\n  PointerDragEvent, Interaction, InteractionSettings, interactionSettingsToStore,\n  DatePointApi,\n  ViewApi,\n} from '@fullcalendar/common'\nimport { FeaturefulElementDragging } from '../dnd/FeaturefulElementDragging'\nimport { HitDragging, isHitsEqual } from './HitDragging'\nimport { buildDatePointApiWithContext } from '../utils'\n\nexport interface DateClickArg extends DatePointApi {\n  dayEl: HTMLElement\n  jsEvent: MouseEvent\n  view: ViewApi\n}\n\n/*\nMonitors when the user clicks on a specific date/time of a component.\nA pointerdown+pointerup on the same \"hit\" constitutes a click.\n*/\nexport class DateClicking extends Interaction {\n  dragging: FeaturefulElementDragging\n  hitDragging: HitDragging\n\n  constructor(settings: InteractionSettings) {\n    super(settings)\n\n    // we DO want to watch pointer moves because otherwise finalHit won't get populated\n    this.dragging = new FeaturefulElementDragging(settings.el)\n    this.dragging.autoScroller.isEnabled = false\n\n    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings))\n    hitDragging.emitter.on('pointerdown', this.handlePointerDown)\n    hitDragging.emitter.on('dragend', this.handleDragEnd)\n  }\n\n  destroy() {\n    this.dragging.destroy()\n  }\n\n  handlePointerDown = (pev: PointerDragEvent) => {\n    let { dragging } = this\n    let downEl = pev.origEvent.target as HTMLElement\n\n    // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n    dragging.setIgnoreMove(\n      !this.component.isValidDateDownEl(downEl),\n    )\n  }\n\n  // won't even fire if moving was ignored\n  handleDragEnd = (ev: PointerDragEvent) => {\n    let { component } = this\n    let { pointer } = this.dragging\n\n    if (!pointer.wasTouchScroll) {\n      let { initialHit, finalHit } = this.hitDragging\n\n      if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n        let { context } = component\n        let arg: DateClickArg = {\n          ...buildDatePointApiWithContext(initialHit.dateSpan, context),\n          dayEl: initialHit.dayEl,\n          jsEvent: ev.origEvent as MouseEvent,\n          view: context.viewApi || context.calendarApi.view,\n        }\n\n        context.emitter.trigger('dateClick', arg)\n      }\n    }\n  }\n}\n","import {\n  compareNumbers, enableCursor, disableCursor, DateComponent, Hit,\n  DateSpan, PointerDragEvent, dateSelectionJoinTransformer,\n  Interaction, InteractionSettings, interactionSettingsToStore,\n  triggerDateSelect, isDateSelectionValid,\n} from '@fullcalendar/common'\nimport { __assign } from 'tslib'\nimport { HitDragging } from './HitDragging'\nimport { FeaturefulElementDragging } from '../dnd/FeaturefulElementDragging'\n\n/*\nTracks when the user selects a portion of time of a component,\nconstituted by a drag over date cells, with a possible delay at the beginning of the drag.\n*/\nexport class DateSelecting extends Interaction {\n  dragging: FeaturefulElementDragging\n  hitDragging: HitDragging\n  dragSelection: DateSpan | null = null\n\n  constructor(settings: InteractionSettings) {\n    super(settings)\n    let { component } = settings\n    let { options } = component.context\n\n    let dragging = this.dragging = new FeaturefulElementDragging(settings.el)\n    dragging.touchScrollAllowed = false\n    dragging.minDistance = options.selectMinDistance || 0\n    dragging.autoScroller.isEnabled = options.dragScroll\n\n    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings))\n    hitDragging.emitter.on('pointerdown', this.handlePointerDown)\n    hitDragging.emitter.on('dragstart', this.handleDragStart)\n    hitDragging.emitter.on('hitupdate', this.handleHitUpdate)\n    hitDragging.emitter.on('pointerup', this.handlePointerUp)\n  }\n\n  destroy() {\n    this.dragging.destroy()\n  }\n\n  handlePointerDown = (ev: PointerDragEvent) => {\n    let { component, dragging } = this\n    let { options } = component.context\n\n    let canSelect = options.selectable &&\n      component.isValidDateDownEl(ev.origEvent.target as HTMLElement)\n\n    // don't bother to watch expensive moves if component won't do selection\n    dragging.setIgnoreMove(!canSelect)\n\n    // if touch, require user to hold down\n    dragging.delay = ev.isTouch ? getComponentTouchDelay(component) : null\n  }\n\n  handleDragStart = (ev: PointerDragEvent) => {\n    this.component.context.calendarApi.unselect(ev) // unselect previous selections\n  }\n\n  handleHitUpdate = (hit: Hit | null, isFinal: boolean) => {\n    let { context } = this.component\n    let dragSelection: DateSpan | null = null\n    let isInvalid = false\n\n    if (hit) {\n      let initialHit = this.hitDragging.initialHit!\n      let disallowed = hit.componentId === initialHit.componentId\n        && this.isHitComboAllowed\n        && !this.isHitComboAllowed(initialHit, hit)\n\n      if (!disallowed) {\n        dragSelection = joinHitsIntoSelection(\n          initialHit,\n          hit,\n          context.pluginHooks.dateSelectionTransformers,\n        )\n      }\n\n      if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {\n        isInvalid = true\n        dragSelection = null\n      }\n    }\n\n    if (dragSelection) {\n      context.dispatch({ type: 'SELECT_DATES', selection: dragSelection })\n    } else if (!isFinal) { // only unselect if moved away while dragging\n      context.dispatch({ type: 'UNSELECT_DATES' })\n    }\n\n    if (!isInvalid) {\n      enableCursor()\n    } else {\n      disableCursor()\n    }\n\n    if (!isFinal) {\n      this.dragSelection = dragSelection // only clear if moved away from all hits while dragging\n    }\n  }\n\n  handlePointerUp = (pev: PointerDragEvent) => {\n    if (this.dragSelection) {\n      // selection is already rendered, so just need to report selection\n      triggerDateSelect(this.dragSelection, pev, this.component.context)\n\n      this.dragSelection = null\n    }\n  }\n}\n\nfunction getComponentTouchDelay(component: DateComponent<any>): number {\n  let { options } = component.context\n  let delay = options.selectLongPressDelay\n\n  if (delay == null) {\n    delay = options.longPressDelay\n  }\n\n  return delay\n}\n\nfunction joinHitsIntoSelection(hit0: Hit, hit1: Hit, dateSelectionTransformers: dateSelectionJoinTransformer[]): DateSpan {\n  let dateSpan0 = hit0.dateSpan\n  let dateSpan1 = hit1.dateSpan\n  let ms = [\n    dateSpan0.range.start,\n    dateSpan0.range.end,\n    dateSpan1.range.start,\n    dateSpan1.range.end,\n  ]\n\n  ms.sort(compareNumbers)\n\n  let props = {} as DateSpan\n\n  for (let transformer of dateSelectionTransformers) {\n    let res = transformer(hit0, hit1)\n\n    if (res === false) {\n      return null\n    }\n\n    if (res) {\n      __assign(props, res)\n    }\n  }\n\n  props.range = { start: ms[0], end: ms[3] }\n  props.allDay = dateSpan0.allDay\n\n  return props\n}\n","import {\n  DateComponent, Seg,\n  PointerDragEvent, Hit,\n  EventMutation, applyMutationToEventStore,\n  startOfDay,\n  elementClosest,\n  EventStore, getRelevantEvents, createEmptyEventStore,\n  EventInteractionState,\n  diffDates, enableCursor, disableCursor,\n  EventRenderRange, getElSeg,\n  EventApi,\n  eventDragMutationMassager,\n  Interaction, InteractionSettings, interactionSettingsStore,\n  EventDropTransformers,\n  CalendarContext,\n  ViewApi,\n  EventChangeArg,\n  buildEventApis,\n  EventAddArg,\n  EventRemoveArg,\n  isInteractionValid,\n  getElRoot,\n} from '@fullcalendar/common'\nimport { __assign } from 'tslib'\nimport { HitDragging, isHitsEqual } from './HitDragging'\nimport { FeaturefulElementDragging } from '../dnd/FeaturefulElementDragging'\nimport { buildDatePointApiWithContext } from '../utils'\n\nexport type EventDragStopArg = EventDragArg\nexport type EventDragStartArg = EventDragArg\n\nexport interface EventDragArg {\n  el: HTMLElement\n  event: EventApi\n  jsEvent: MouseEvent\n  view: ViewApi\n}\n\nexport class EventDragging extends Interaction { // TODO: rename to EventSelectingAndDragging\n  // TODO: test this in IE11\n  // QUESTION: why do we need it on the resizable???\n  static SELECTOR = '.fc-event-draggable, .fc-event-resizable'\n\n  dragging: FeaturefulElementDragging\n  hitDragging: HitDragging\n\n  // internal state\n  subjectEl: HTMLElement | null = null\n  subjectSeg: Seg | null = null // the seg being selected/dragged\n  isDragging: boolean = false\n  eventRange: EventRenderRange | null = null\n  relevantEvents: EventStore | null = null // the events being dragged\n  receivingContext: CalendarContext | null = null\n  validMutation: EventMutation | null = null\n  mutatedRelevantEvents: EventStore | null = null\n\n  constructor(settings: InteractionSettings) {\n    super(settings)\n    let { component } = this\n    let { options } = component.context\n\n    let dragging = this.dragging = new FeaturefulElementDragging(settings.el)\n    dragging.pointer.selector = EventDragging.SELECTOR\n    dragging.touchScrollAllowed = false\n    dragging.autoScroller.isEnabled = options.dragScroll\n\n    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore)\n    hitDragging.useSubjectCenter = settings.useEventCenter\n    hitDragging.emitter.on('pointerdown', this.handlePointerDown)\n    hitDragging.emitter.on('dragstart', this.handleDragStart)\n    hitDragging.emitter.on('hitupdate', this.handleHitUpdate)\n    hitDragging.emitter.on('pointerup', this.handlePointerUp)\n    hitDragging.emitter.on('dragend', this.handleDragEnd)\n  }\n\n  destroy() {\n    this.dragging.destroy()\n  }\n\n  handlePointerDown = (ev: PointerDragEvent) => {\n    let origTarget = ev.origEvent.target as HTMLElement\n    let { component, dragging } = this\n    let { mirror } = dragging\n    let { options } = component.context\n    let initialContext = component.context\n    this.subjectEl = ev.subjectEl as HTMLElement\n    let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl as HTMLElement)!\n    let eventRange = this.eventRange = subjectSeg.eventRange!\n    let eventInstanceId = eventRange.instance!.instanceId\n\n    this.relevantEvents = getRelevantEvents(\n      initialContext.getCurrentData().eventStore,\n      eventInstanceId,\n    )\n\n    dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance\n    dragging.delay =\n      // only do a touch delay if touch and this event hasn't been selected yet\n      (ev.isTouch && eventInstanceId !== component.props.eventSelection) ?\n        getComponentTouchDelay(component) :\n        null\n\n    if (options.fixedMirrorParent) {\n      mirror.parentNode = options.fixedMirrorParent\n    } else {\n      mirror.parentNode = elementClosest(origTarget, '.fc')\n    }\n\n    mirror.revertDuration = options.dragRevertDuration\n\n    let isValid =\n      component.isValidSegDownEl(origTarget) &&\n      !elementClosest(origTarget, '.fc-event-resizer') // NOT on a resizer\n\n    dragging.setIgnoreMove(!isValid)\n\n    // disable dragging for elements that are resizable (ie, selectable)\n    // but are not draggable\n    this.isDragging = isValid &&\n      (ev.subjectEl as HTMLElement).classList.contains('fc-event-draggable')\n  }\n\n  handleDragStart = (ev: PointerDragEvent) => {\n    let initialContext = this.component.context\n    let eventRange = this.eventRange!\n    let eventInstanceId = eventRange.instance.instanceId\n\n    if (ev.isTouch) {\n      // need to select a different event?\n      if (eventInstanceId !== this.component.props.eventSelection) {\n        initialContext.dispatch({ type: 'SELECT_EVENT', eventInstanceId })\n      }\n    } else {\n      // if now using mouse, but was previous touch interaction, clear selected event\n      initialContext.dispatch({ type: 'UNSELECT_EVENT' })\n    }\n\n    if (this.isDragging) {\n      initialContext.calendarApi.unselect(ev) // unselect *date* selection\n      initialContext.emitter.trigger('eventDragStart', {\n        el: this.subjectEl,\n        event: new EventApi(initialContext, eventRange.def, eventRange.instance),\n        jsEvent: ev.origEvent as MouseEvent, // Is this always a mouse event? See #4655\n        view: initialContext.viewApi,\n      } as EventDragStartArg)\n    }\n  }\n\n  handleHitUpdate = (hit: Hit | null, isFinal: boolean) => {\n    if (!this.isDragging) {\n      return\n    }\n\n    let relevantEvents = this.relevantEvents!\n    let initialHit = this.hitDragging.initialHit!\n    let initialContext = this.component.context\n\n    // states based on new hit\n    let receivingContext: CalendarContext | null = null\n    let mutation: EventMutation | null = null\n    let mutatedRelevantEvents: EventStore | null = null\n    let isInvalid = false\n    let interaction: EventInteractionState = {\n      affectedEvents: relevantEvents,\n      mutatedEvents: createEmptyEventStore(),\n      isEvent: true,\n    }\n\n    if (hit) {\n      receivingContext = hit.context\n      let receivingOptions = receivingContext.options\n\n      if (\n        initialContext === receivingContext ||\n        (receivingOptions.editable && receivingOptions.droppable)\n      ) {\n        mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers)\n\n        if (mutation) {\n          mutatedRelevantEvents = applyMutationToEventStore(\n            relevantEvents,\n            receivingContext.getCurrentData().eventUiBases,\n            mutation,\n            receivingContext,\n          )\n          interaction.mutatedEvents = mutatedRelevantEvents\n\n          if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {\n            isInvalid = true\n            mutation = null\n            mutatedRelevantEvents = null\n            interaction.mutatedEvents = createEmptyEventStore()\n          }\n        }\n      } else {\n        receivingContext = null\n      }\n    }\n\n    this.displayDrag(receivingContext, interaction)\n\n    if (!isInvalid) {\n      enableCursor()\n    } else {\n      disableCursor()\n    }\n\n    if (!isFinal) {\n      if (\n        initialContext === receivingContext && // TODO: write test for this\n        isHitsEqual(initialHit, hit)\n      ) {\n        mutation = null\n      }\n\n      this.dragging.setMirrorNeedsRevert(!mutation)\n\n      // render the mirror if no already-rendered mirror\n      // TODO: wish we could somehow wait for dispatch to guarantee render\n      this.dragging.setMirrorIsVisible(\n        !hit || !getElRoot(this.subjectEl).querySelector('.fc-event-mirror'), // TODO: turn className into constant\n      )\n\n      // assign states based on new hit\n      this.receivingContext = receivingContext\n      this.validMutation = mutation\n      this.mutatedRelevantEvents = mutatedRelevantEvents\n    }\n  }\n\n  handlePointerUp = () => {\n    if (!this.isDragging) {\n      this.cleanup() // because handleDragEnd won't fire\n    }\n  }\n\n  handleDragEnd = (ev: PointerDragEvent) => {\n    if (this.isDragging) {\n      let initialContext = this.component.context\n      let initialView = initialContext.viewApi\n      let { receivingContext, validMutation } = this\n      let eventDef = this.eventRange!.def\n      let eventInstance = this.eventRange!.instance\n      let eventApi = new EventApi(initialContext, eventDef, eventInstance)\n      let relevantEvents = this.relevantEvents!\n      let mutatedRelevantEvents = this.mutatedRelevantEvents!\n      let { finalHit } = this.hitDragging\n\n      this.clearDrag() // must happen after revert animation\n\n      initialContext.emitter.trigger('eventDragStop', {\n        el: this.subjectEl,\n        event: eventApi,\n        jsEvent: ev.origEvent as MouseEvent, // Is this always a mouse event? See #4655\n        view: initialView,\n      } as EventDragStopArg)\n\n      if (validMutation) {\n        // dropped within same calendar\n        if (receivingContext === initialContext) {\n          let updatedEventApi = new EventApi(\n            initialContext,\n            mutatedRelevantEvents.defs[eventDef.defId],\n            eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null,\n          )\n\n          initialContext.dispatch({\n            type: 'MERGE_EVENTS',\n            eventStore: mutatedRelevantEvents,\n          })\n\n          let eventChangeArg: EventChangeArg = {\n            oldEvent: eventApi,\n            event: updatedEventApi,\n            relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),\n            revert() {\n              initialContext.dispatch({\n                type: 'MERGE_EVENTS',\n                eventStore: relevantEvents, // the pre-change data\n              })\n            },\n          }\n\n          let transformed: ReturnType<EventDropTransformers> = {}\n          for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {\n            __assign(transformed, transformer(validMutation, initialContext))\n          }\n\n          initialContext.emitter.trigger('eventDrop', {\n            ...eventChangeArg,\n            ...transformed,\n            el: ev.subjectEl as HTMLElement,\n            delta: validMutation.datesDelta!,\n            jsEvent: ev.origEvent as MouseEvent, // bad\n            view: initialView,\n          })\n\n          initialContext.emitter.trigger('eventChange', eventChangeArg)\n\n        // dropped in different calendar\n        } else if (receivingContext) {\n          let eventRemoveArg: EventRemoveArg = {\n            event: eventApi,\n            relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),\n            revert() {\n              initialContext.dispatch({\n                type: 'MERGE_EVENTS',\n                eventStore: relevantEvents,\n              })\n            },\n          }\n\n          initialContext.emitter.trigger('eventLeave', {\n            ...eventRemoveArg,\n            draggedEl: ev.subjectEl as HTMLElement,\n            view: initialView,\n          })\n\n          initialContext.dispatch({\n            type: 'REMOVE_EVENTS',\n            eventStore: relevantEvents,\n          })\n\n          initialContext.emitter.trigger('eventRemove', eventRemoveArg)\n\n          let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId]\n          let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId]\n          let addedEventApi = new EventApi(receivingContext, addedEventDef, addedEventInstance)\n\n          receivingContext.dispatch({\n            type: 'MERGE_EVENTS',\n            eventStore: mutatedRelevantEvents,\n          })\n\n          let eventAddArg: EventAddArg = {\n            event: addedEventApi,\n            relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),\n            revert() {\n              receivingContext.dispatch({\n                type: 'REMOVE_EVENTS',\n                eventStore: mutatedRelevantEvents,\n              })\n            },\n          }\n\n          receivingContext.emitter.trigger('eventAdd', eventAddArg)\n\n          if (ev.isTouch) {\n            receivingContext.dispatch({\n              type: 'SELECT_EVENT',\n              eventInstanceId: eventInstance.instanceId,\n            })\n          }\n\n          receivingContext.emitter.trigger('drop', {\n            ...buildDatePointApiWithContext(finalHit.dateSpan, receivingContext),\n            draggedEl: ev.subjectEl as HTMLElement,\n            jsEvent: ev.origEvent as MouseEvent, // Is this always a mouse event? See #4655\n            view: finalHit.context.viewApi,\n          })\n\n          receivingContext.emitter.trigger('eventReceive', {\n            ...eventAddArg,\n            draggedEl: ev.subjectEl as HTMLElement,\n            view: finalHit.context.viewApi,\n          })\n        }\n      } else {\n        initialContext.emitter.trigger('_noEventDrop')\n      }\n    }\n\n    this.cleanup()\n  }\n\n  // render a drag state on the next receivingCalendar\n  displayDrag(nextContext: CalendarContext | null, state: EventInteractionState) {\n    let initialContext = this.component.context\n    let prevContext = this.receivingContext\n\n    // does the previous calendar need to be cleared?\n    if (prevContext && prevContext !== nextContext) {\n      // does the initial calendar need to be cleared?\n      // if so, don't clear all the way. we still need to to hide the affectedEvents\n      if (prevContext === initialContext) {\n        prevContext.dispatch({\n          type: 'SET_EVENT_DRAG',\n          state: {\n            affectedEvents: state.affectedEvents,\n            mutatedEvents: createEmptyEventStore(),\n            isEvent: true,\n          },\n        })\n\n      // completely clear the old calendar if it wasn't the initial\n      } else {\n        prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' })\n      }\n    }\n\n    if (nextContext) {\n      nextContext.dispatch({ type: 'SET_EVENT_DRAG', state })\n    }\n  }\n\n  clearDrag() {\n    let initialCalendar = this.component.context\n    let { receivingContext } = this\n\n    if (receivingContext) {\n      receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' })\n    }\n\n    // the initial calendar might have an dummy drag state from displayDrag\n    if (initialCalendar !== receivingContext) {\n      initialCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' })\n    }\n  }\n\n  cleanup() { // reset all internal state\n    this.subjectSeg = null\n    this.isDragging = false\n    this.eventRange = null\n    this.relevantEvents = null\n    this.receivingContext = null\n    this.validMutation = null\n    this.mutatedRelevantEvents = null\n  }\n}\n\nfunction computeEventMutation(hit0: Hit, hit1: Hit, massagers: eventDragMutationMassager[]): EventMutation {\n  let dateSpan0 = hit0.dateSpan\n  let dateSpan1 = hit1.dateSpan\n  let date0 = dateSpan0.range.start\n  let date1 = dateSpan1.range.start\n  let standardProps = {} as any\n\n  if (dateSpan0.allDay !== dateSpan1.allDay) {\n    standardProps.allDay = dateSpan1.allDay\n    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration\n\n    if (dateSpan1.allDay) {\n      // means date1 is already start-of-day,\n      // but date0 needs to be converted\n      date0 = startOfDay(date0)\n    }\n  }\n\n  let delta = diffDates(\n    date0, date1,\n    hit0.context.dateEnv,\n    hit0.componentId === hit1.componentId ?\n      hit0.largeUnit :\n      null,\n  )\n\n  if (delta.milliseconds) { // has hours/minutes/seconds\n    standardProps.allDay = false\n  }\n\n  let mutation: EventMutation = {\n    datesDelta: delta,\n    standardProps,\n  }\n\n  for (let massager of massagers) {\n    massager(mutation, hit0, hit1)\n  }\n\n  return mutation\n}\n\nfunction getComponentTouchDelay(component: DateComponent<any>): number | null {\n  let { options } = component.context\n  let delay = options.eventLongPressDelay\n\n  if (delay == null) {\n    delay = options.longPressDelay\n  }\n\n  return delay\n}\n","import {\n  Seg, Hit,\n  EventMutation, applyMutationToEventStore,\n  elementClosest,\n  PointerDragEvent,\n  EventStore, getRelevantEvents, createEmptyEventStore,\n  diffDates, enableCursor, disableCursor,\n  DateRange,\n  EventApi,\n  EventRenderRange, getElSeg,\n  createDuration,\n  EventInteractionState,\n  Interaction, InteractionSettings, interactionSettingsToStore, ViewApi, Duration, EventChangeArg, buildEventApis, isInteractionValid,\n} from '@fullcalendar/common'\nimport { __assign } from 'tslib'\nimport { HitDragging, isHitsEqual } from './HitDragging'\nimport { FeaturefulElementDragging } from '../dnd/FeaturefulElementDragging'\n\nexport type EventResizeStartArg = EventResizeStartStopArg\nexport type EventResizeStopArg = EventResizeStartStopArg\n\nexport interface EventResizeStartStopArg {\n  el: HTMLElement\n  event: EventApi\n  jsEvent: MouseEvent\n  view: ViewApi\n}\n\nexport interface EventResizeDoneArg extends EventChangeArg {\n  el: HTMLElement\n  startDelta: Duration\n  endDelta: Duration\n  jsEvent: MouseEvent\n  view: ViewApi\n}\n\nexport class EventResizing extends Interaction {\n  dragging: FeaturefulElementDragging\n  hitDragging: HitDragging\n\n  // internal state\n  draggingSegEl: HTMLElement | null = null\n  draggingSeg: Seg | null = null // TODO: rename to resizingSeg? subjectSeg?\n  eventRange: EventRenderRange | null = null\n  relevantEvents: EventStore | null = null\n  validMutation: EventMutation | null = null\n  mutatedRelevantEvents: EventStore | null = null\n\n  constructor(settings: InteractionSettings) {\n    super(settings)\n    let { component } = settings\n\n    let dragging = this.dragging = new FeaturefulElementDragging(settings.el)\n    dragging.pointer.selector = '.fc-event-resizer'\n    dragging.touchScrollAllowed = false\n    dragging.autoScroller.isEnabled = component.context.options.dragScroll\n\n    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings))\n    hitDragging.emitter.on('pointerdown', this.handlePointerDown)\n    hitDragging.emitter.on('dragstart', this.handleDragStart)\n    hitDragging.emitter.on('hitupdate', this.handleHitUpdate)\n    hitDragging.emitter.on('dragend', this.handleDragEnd)\n  }\n\n  destroy() {\n    this.dragging.destroy()\n  }\n\n  handlePointerDown = (ev: PointerDragEvent) => {\n    let { component } = this\n    let segEl = this.querySegEl(ev)\n    let seg = getElSeg(segEl)\n    let eventRange = this.eventRange = seg.eventRange!\n\n    this.dragging.minDistance = component.context.options.eventDragMinDistance\n\n    // if touch, need to be working with a selected event\n    this.dragging.setIgnoreMove(\n      !this.component.isValidSegDownEl(ev.origEvent.target as HTMLElement) ||\n      (ev.isTouch && this.component.props.eventSelection !== eventRange.instance!.instanceId),\n    )\n  }\n\n  handleDragStart = (ev: PointerDragEvent) => {\n    let { context } = this.component\n    let eventRange = this.eventRange!\n\n    this.relevantEvents = getRelevantEvents(\n      context.getCurrentData().eventStore,\n      this.eventRange.instance!.instanceId,\n    )\n\n    let segEl = this.querySegEl(ev)\n    this.draggingSegEl = segEl\n    this.draggingSeg = getElSeg(segEl)\n\n    context.calendarApi.unselect()\n    context.emitter.trigger('eventResizeStart', {\n      el: segEl,\n      event: new EventApi(context, eventRange.def, eventRange.instance),\n      jsEvent: ev.origEvent as MouseEvent, // Is this always a mouse event? See #4655\n      view: context.viewApi,\n    } as EventResizeStartArg)\n  }\n\n  handleHitUpdate = (hit: Hit | null, isFinal: boolean, ev: PointerDragEvent) => {\n    let { context } = this.component\n    let relevantEvents = this.relevantEvents!\n    let initialHit = this.hitDragging.initialHit!\n    let eventInstance = this.eventRange.instance!\n    let mutation: EventMutation | null = null\n    let mutatedRelevantEvents: EventStore | null = null\n    let isInvalid = false\n    let interaction: EventInteractionState = {\n      affectedEvents: relevantEvents,\n      mutatedEvents: createEmptyEventStore(),\n      isEvent: true,\n    }\n\n    if (hit) {\n      let disallowed = hit.componentId === initialHit.componentId\n        && this.isHitComboAllowed\n        && !this.isHitComboAllowed(initialHit, hit)\n\n      if (!disallowed) {\n        mutation = computeMutation(\n          initialHit,\n          hit,\n          (ev.subjectEl as HTMLElement).classList.contains('fc-event-resizer-start'),\n          eventInstance.range,\n        )\n      }\n    }\n\n    if (mutation) {\n      mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context)\n      interaction.mutatedEvents = mutatedRelevantEvents\n\n      if (!isInteractionValid(interaction, hit.dateProfile, context)) {\n        isInvalid = true\n        mutation = null\n        mutatedRelevantEvents = null\n        interaction.mutatedEvents = null\n      }\n    }\n\n    if (mutatedRelevantEvents) {\n      context.dispatch({\n        type: 'SET_EVENT_RESIZE',\n        state: interaction,\n      })\n    } else {\n      context.dispatch({ type: 'UNSET_EVENT_RESIZE' })\n    }\n\n    if (!isInvalid) {\n      enableCursor()\n    } else {\n      disableCursor()\n    }\n\n    if (!isFinal) {\n      if (mutation && isHitsEqual(initialHit, hit)) {\n        mutation = null\n      }\n\n      this.validMutation = mutation\n      this.mutatedRelevantEvents = mutatedRelevantEvents\n    }\n  }\n\n  handleDragEnd = (ev: PointerDragEvent) => {\n    let { context } = this.component\n    let eventDef = this.eventRange!.def\n    let eventInstance = this.eventRange!.instance\n    let eventApi = new EventApi(context, eventDef, eventInstance)\n    let relevantEvents = this.relevantEvents!\n    let mutatedRelevantEvents = this.mutatedRelevantEvents!\n\n    context.emitter.trigger('eventResizeStop', {\n      el: this.draggingSegEl,\n      event: eventApi,\n      jsEvent: ev.origEvent as MouseEvent, // Is this always a mouse event? See #4655\n      view: context.viewApi,\n    } as EventResizeStopArg)\n\n    if (this.validMutation) {\n      let updatedEventApi = new EventApi(\n        context,\n        mutatedRelevantEvents.defs[eventDef.defId],\n        eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null,\n      )\n\n      context.dispatch({\n        type: 'MERGE_EVENTS',\n        eventStore: mutatedRelevantEvents,\n      })\n\n      let eventChangeArg: EventChangeArg = {\n        oldEvent: eventApi,\n        event: updatedEventApi,\n        relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),\n        revert() {\n          context.dispatch({\n            type: 'MERGE_EVENTS',\n            eventStore: relevantEvents, // the pre-change events\n          })\n        },\n      }\n\n      context.emitter.trigger('eventResize', {\n        ...eventChangeArg,\n        el: this.draggingSegEl,\n        startDelta: this.validMutation.startDelta || createDuration(0),\n        endDelta: this.validMutation.endDelta || createDuration(0),\n        jsEvent: ev.origEvent as MouseEvent,\n        view: context.viewApi,\n      })\n\n      context.emitter.trigger('eventChange', eventChangeArg)\n    } else {\n      context.emitter.trigger('_noEventResize')\n    }\n\n    // reset all internal state\n    this.draggingSeg = null\n    this.relevantEvents = null\n    this.validMutation = null\n\n    // okay to keep eventInstance around. useful to set it in handlePointerDown\n  }\n\n  querySegEl(ev: PointerDragEvent) {\n    return elementClosest(ev.subjectEl as HTMLElement, '.fc-event')\n  }\n}\n\nfunction computeMutation(\n  hit0: Hit,\n  hit1: Hit,\n  isFromStart: boolean,\n  instanceRange: DateRange,\n): EventMutation | null {\n  let dateEnv = hit0.context.dateEnv\n  let date0 = hit0.dateSpan.range.start\n  let date1 = hit1.dateSpan.range.start\n\n  let delta = diffDates(\n    date0, date1,\n    dateEnv,\n    hit0.largeUnit,\n  )\n\n  if (isFromStart) {\n    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n      return { startDelta: delta }\n    }\n  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n    return { endDelta: delta }\n  }\n\n  return null\n}\n","import {\n  DateSelectionApi,\n  PointerDragEvent,\n  elementClosest,\n  CalendarContext,\n  getEventTargetViaRoot,\n} from '@fullcalendar/common'\nimport { PointerDragging } from '../dnd/PointerDragging'\nimport { EventDragging } from './EventDragging'\n\nexport class UnselectAuto {\n  documentPointer: PointerDragging // for unfocusing\n  isRecentPointerDateSelect = false // wish we could use a selector to detect date selection, but uses hit system\n  matchesCancel = false\n  matchesEvent = false\n\n  constructor(private context: CalendarContext) {\n    let documentPointer = this.documentPointer = new PointerDragging(document)\n    documentPointer.shouldIgnoreMove = true\n    documentPointer.shouldWatchScroll = false\n    documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown)\n    documentPointer.emitter.on('pointerup', this.onDocumentPointerUp)\n\n    /*\n    TODO: better way to know about whether there was a selection with the pointer\n    */\n    context.emitter.on('select', this.onSelect)\n  }\n\n  destroy() {\n    this.context.emitter.off('select', this.onSelect)\n    this.documentPointer.destroy()\n  }\n\n  onSelect = (selectInfo: DateSelectionApi) => {\n    if (selectInfo.jsEvent) {\n      this.isRecentPointerDateSelect = true\n    }\n  }\n\n  onDocumentPointerDown = (pev: PointerDragEvent) => {\n    let unselectCancel = this.context.options.unselectCancel\n    let downEl = getEventTargetViaRoot(pev.origEvent) as HTMLElement\n\n    this.matchesCancel = !!elementClosest(downEl, unselectCancel)\n    this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR) // interaction started on an event?\n  }\n\n  onDocumentPointerUp = (pev: PointerDragEvent) => {\n    let { context } = this\n    let { documentPointer } = this\n    let calendarState = context.getCurrentData()\n\n    // touch-scrolling should never unfocus any type of selection\n    if (!documentPointer.wasTouchScroll) {\n      if (\n        calendarState.dateSelection && // an existing date selection?\n        !this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n      ) {\n        let unselectAuto = context.options.unselectAuto\n\n        if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {\n          context.calendarApi.unselect(pev)\n        }\n      }\n\n      if (\n        calendarState.eventSelection && // an existing event selected?\n        !this.matchesEvent // interaction DIDN'T start on an event\n      ) {\n        context.dispatch({ type: 'UNSELECT_EVENT' })\n      }\n    }\n\n    this.isRecentPointerDateSelect = false\n  }\n}\n","import {\n  Hit,\n  interactionSettingsStore,\n  PointerDragEvent,\n  parseEventDef, createEventInstance, EventTuple,\n  createEmptyEventStore, eventTupleToStore,\n  config,\n  DateSpan, DatePointApi,\n  EventInteractionState,\n  DragMetaInput, DragMeta, parseDragMeta,\n  EventApi,\n  elementMatches,\n  enableCursor, disableCursor,\n  isInteractionValid,\n  ElementDragging,\n  ViewApi,\n  CalendarContext,\n  getDefaultEventEnd,\n  refineEventDef,\n} from '@fullcalendar/common'\nimport { __assign } from 'tslib'\nimport { HitDragging } from '../interactions/HitDragging'\nimport { buildDatePointApiWithContext } from '../utils'\n\nexport type DragMetaGenerator = DragMetaInput | ((el: HTMLElement) => DragMetaInput)\n\nexport interface ExternalDropApi extends DatePointApi {\n  draggedEl: HTMLElement\n  jsEvent: UIEvent\n  view: ViewApi\n}\n\n/*\nGiven an already instantiated draggable object for one-or-more elements,\nInterprets any dragging as an attempt to drag an events that lives outside\nof a calendar onto a calendar.\n*/\nexport class ExternalElementDragging {\n  hitDragging: HitDragging\n  receivingContext: CalendarContext | null = null\n  droppableEvent: EventTuple | null = null // will exist for all drags, even if create:false\n  suppliedDragMeta: DragMetaGenerator | null = null\n  dragMeta: DragMeta | null = null\n\n  constructor(dragging: ElementDragging, suppliedDragMeta?: DragMetaGenerator) {\n    let hitDragging = this.hitDragging = new HitDragging(dragging, interactionSettingsStore)\n    hitDragging.requireInitial = false // will start outside of a component\n    hitDragging.emitter.on('dragstart', this.handleDragStart)\n    hitDragging.emitter.on('hitupdate', this.handleHitUpdate)\n    hitDragging.emitter.on('dragend', this.handleDragEnd)\n\n    this.suppliedDragMeta = suppliedDragMeta\n  }\n\n  handleDragStart = (ev: PointerDragEvent) => {\n    this.dragMeta = this.buildDragMeta(ev.subjectEl as HTMLElement)\n  }\n\n  buildDragMeta(subjectEl: HTMLElement) {\n    if (typeof this.suppliedDragMeta === 'object') {\n      return parseDragMeta(this.suppliedDragMeta)\n    }\n    if (typeof this.suppliedDragMeta === 'function') {\n      return parseDragMeta(this.suppliedDragMeta(subjectEl))\n    }\n    return getDragMetaFromEl(subjectEl)\n  }\n\n  handleHitUpdate = (hit: Hit | null, isFinal: boolean, ev: PointerDragEvent) => {\n    let { dragging } = this.hitDragging\n    let receivingContext: CalendarContext | null = null\n    let droppableEvent: EventTuple | null = null\n    let isInvalid = false\n    let interaction: EventInteractionState = {\n      affectedEvents: createEmptyEventStore(),\n      mutatedEvents: createEmptyEventStore(),\n      isEvent: this.dragMeta!.create,\n    }\n\n    if (hit) {\n      receivingContext = hit.context\n\n      if (this.canDropElOnCalendar(ev.subjectEl as HTMLElement, receivingContext)) {\n        droppableEvent = computeEventForDateSpan(\n          hit.dateSpan,\n          this.dragMeta!,\n          receivingContext,\n        )\n\n        interaction.mutatedEvents = eventTupleToStore(droppableEvent)\n        isInvalid = !isInteractionValid(interaction, hit.dateProfile, receivingContext)\n\n        if (isInvalid) {\n          interaction.mutatedEvents = createEmptyEventStore()\n          droppableEvent = null\n        }\n      }\n    }\n\n    this.displayDrag(receivingContext, interaction)\n\n    // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n    // TODO: wish we could somehow wait for dispatch to guarantee render\n    dragging.setMirrorIsVisible(\n      isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'), // TODO: turn className into constant\n      // TODO: somehow query FullCalendars WITHIN shadow-roots for existing event-mirror els\n    )\n\n    if (!isInvalid) {\n      enableCursor()\n    } else {\n      disableCursor()\n    }\n\n    if (!isFinal) {\n      dragging.setMirrorNeedsRevert(!droppableEvent)\n\n      this.receivingContext = receivingContext\n      this.droppableEvent = droppableEvent\n    }\n  }\n\n  handleDragEnd = (pev: PointerDragEvent) => {\n    let { receivingContext, droppableEvent } = this\n\n    this.clearDrag()\n\n    if (receivingContext && droppableEvent) {\n      let finalHit = this.hitDragging.finalHit!\n      let finalView = finalHit.context.viewApi\n      let dragMeta = this.dragMeta!\n\n      receivingContext.emitter.trigger('drop', {\n        ...buildDatePointApiWithContext(finalHit.dateSpan, receivingContext),\n        draggedEl: pev.subjectEl as HTMLElement,\n        jsEvent: pev.origEvent as MouseEvent, // Is this always a mouse event? See #4655\n        view: finalView,\n      })\n\n      if (dragMeta.create) {\n        let addingEvents = eventTupleToStore(droppableEvent)\n\n        receivingContext.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: addingEvents,\n        })\n\n        if (pev.isTouch) {\n          receivingContext.dispatch({\n            type: 'SELECT_EVENT',\n            eventInstanceId: droppableEvent.instance.instanceId,\n          })\n        }\n\n        // signal that an external event landed\n        receivingContext.emitter.trigger('eventReceive', {\n          event: new EventApi(\n            receivingContext,\n            droppableEvent.def,\n            droppableEvent.instance,\n          ),\n          relatedEvents: [],\n          revert() {\n            receivingContext.dispatch({\n              type: 'REMOVE_EVENTS',\n              eventStore: addingEvents,\n            })\n          },\n          draggedEl: pev.subjectEl as HTMLElement,\n          view: finalView,\n        })\n      }\n    }\n\n    this.receivingContext = null\n    this.droppableEvent = null\n  }\n\n  displayDrag(nextContext: CalendarContext | null, state: EventInteractionState) {\n    let prevContext = this.receivingContext\n\n    if (prevContext && prevContext !== nextContext) {\n      prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' })\n    }\n\n    if (nextContext) {\n      nextContext.dispatch({ type: 'SET_EVENT_DRAG', state })\n    }\n  }\n\n  clearDrag() {\n    if (this.receivingContext) {\n      this.receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' })\n    }\n  }\n\n  canDropElOnCalendar(el: HTMLElement, receivingContext: CalendarContext): boolean {\n    let dropAccept = receivingContext.options.dropAccept\n\n    if (typeof dropAccept === 'function') {\n      return dropAccept.call(receivingContext.calendarApi, el)\n    }\n\n    if (typeof dropAccept === 'string' && dropAccept) {\n      return Boolean(elementMatches(el, dropAccept))\n    }\n\n    return true\n  }\n}\n\n// Utils for computing event store from the DragMeta\n// ----------------------------------------------------------------------------------------------------\n\nfunction computeEventForDateSpan(dateSpan: DateSpan, dragMeta: DragMeta, context: CalendarContext): EventTuple {\n  let defProps = { ...dragMeta.leftoverProps }\n\n  for (let transform of context.pluginHooks.externalDefTransforms) {\n    __assign(defProps, transform(dateSpan, dragMeta))\n  }\n\n  let { refined, extra } = refineEventDef(defProps, context)\n  let def = parseEventDef(\n    refined,\n    extra,\n    dragMeta.sourceId,\n    dateSpan.allDay,\n    context.options.forceEventDuration || Boolean(dragMeta.duration), // hasEnd\n    context,\n  )\n\n  let start = dateSpan.range.start\n\n  // only rely on time info if drop zone is all-day,\n  // otherwise, we already know the time\n  if (dateSpan.allDay && dragMeta.startTime) {\n    start = context.dateEnv.add(start, dragMeta.startTime)\n  }\n\n  let end = dragMeta.duration ?\n    context.dateEnv.add(start, dragMeta.duration) :\n    getDefaultEventEnd(dateSpan.allDay, start, context)\n\n  let instance = createEventInstance(def.defId, { start, end })\n\n  return { def, instance }\n}\n\n// Utils for extracting data from element\n// ----------------------------------------------------------------------------------------------------\n\nfunction getDragMetaFromEl(el: HTMLElement): DragMeta {\n  let str = getEmbeddedElData(el, 'event')\n  let obj = str ?\n    JSON.parse(str) :\n    { create: false } // if no embedded data, assume no event creation\n\n  return parseDragMeta(obj)\n}\n\nconfig.dataAttrPrefix = ''\n\nfunction getEmbeddedElData(el: HTMLElement, name: string): string {\n  let prefix = config.dataAttrPrefix\n  let prefixedName = (prefix ? prefix + '-' : '') + name\n\n  return el.getAttribute('data-' + prefixedName) || ''\n}\n","import { BASE_OPTION_DEFAULTS, PointerDragEvent } from '@fullcalendar/common'\nimport { FeaturefulElementDragging } from '../dnd/FeaturefulElementDragging'\nimport { ExternalElementDragging, DragMetaGenerator } from './ExternalElementDragging'\n\nexport interface ExternalDraggableSettings {\n  eventData?: DragMetaGenerator\n  itemSelector?: string\n  minDistance?: number\n  longPressDelay?: number\n  appendTo?: HTMLElement\n}\n\n/*\nMakes an element (that is *external* to any calendar) draggable.\nCan pass in data that determines how an event will be created when dropped onto a calendar.\nLeverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n*/\nexport class ExternalDraggable {\n  dragging: FeaturefulElementDragging\n  settings: ExternalDraggableSettings\n\n  constructor(el: HTMLElement, settings: ExternalDraggableSettings = {}) {\n    this.settings = settings\n\n    let dragging = this.dragging = new FeaturefulElementDragging(el)\n    dragging.touchScrollAllowed = false\n\n    if (settings.itemSelector != null) {\n      dragging.pointer.selector = settings.itemSelector\n    }\n\n    if (settings.appendTo != null) {\n      dragging.mirror.parentNode = settings.appendTo // TODO: write tests\n    }\n\n    dragging.emitter.on('pointerdown', this.handlePointerDown)\n    dragging.emitter.on('dragstart', this.handleDragStart)\n\n    new ExternalElementDragging(dragging, settings.eventData) // eslint-disable-line no-new\n  }\n\n  handlePointerDown = (ev: PointerDragEvent) => {\n    let { dragging } = this\n    let { minDistance, longPressDelay } = this.settings\n\n    dragging.minDistance =\n      minDistance != null ?\n        minDistance :\n        (ev.isTouch ? 0 : BASE_OPTION_DEFAULTS.eventDragMinDistance)\n\n    dragging.delay =\n      ev.isTouch ? // TODO: eventually read eventLongPressDelay instead vvv\n        (longPressDelay != null ? longPressDelay : BASE_OPTION_DEFAULTS.longPressDelay) :\n        0\n  }\n\n  handleDragStart = (ev: PointerDragEvent) => {\n    if (\n      ev.isTouch &&\n      this.dragging.delay &&\n      (ev.subjectEl as HTMLElement).classList.contains('fc-event')\n    ) {\n      this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected')\n    }\n  }\n\n  destroy() {\n    this.dragging.destroy()\n  }\n}\n","import { PointerDragEvent, ElementDragging } from '@fullcalendar/common'\nimport { PointerDragging } from '../dnd/PointerDragging'\n\n/*\nDetects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\nThe third-party system is responsible for drawing the visuals effects of the drag.\nThis class simply monitors for pointer movements and fires events.\nIt also has the ability to hide the moving element (the \"mirror\") during the drag.\n*/\nexport class InferredElementDragging extends ElementDragging {\n  pointer: PointerDragging\n  shouldIgnoreMove: boolean = false\n  mirrorSelector: string = ''\n  currentMirrorEl: HTMLElement | null = null\n\n  constructor(containerEl: HTMLElement) {\n    super(containerEl)\n\n    let pointer = this.pointer = new PointerDragging(containerEl)\n    pointer.emitter.on('pointerdown', this.handlePointerDown)\n    pointer.emitter.on('pointermove', this.handlePointerMove)\n    pointer.emitter.on('pointerup', this.handlePointerUp)\n  }\n\n  destroy() {\n    this.pointer.destroy()\n  }\n\n  handlePointerDown = (ev: PointerDragEvent) => {\n    this.emitter.trigger('pointerdown', ev)\n\n    if (!this.shouldIgnoreMove) {\n      // fire dragstart right away. does not support delay or min-distance\n      this.emitter.trigger('dragstart', ev)\n    }\n  }\n\n  handlePointerMove = (ev: PointerDragEvent) => {\n    if (!this.shouldIgnoreMove) {\n      this.emitter.trigger('dragmove', ev)\n    }\n  }\n\n  handlePointerUp = (ev: PointerDragEvent) => {\n    this.emitter.trigger('pointerup', ev)\n\n    if (!this.shouldIgnoreMove) {\n      // fire dragend right away. does not support a revert animation\n      this.emitter.trigger('dragend', ev)\n    }\n  }\n\n  setIgnoreMove(bool: boolean) {\n    this.shouldIgnoreMove = bool\n  }\n\n  setMirrorIsVisible(bool: boolean) {\n    if (bool) {\n      // restore a previously hidden element.\n      // use the reference in case the selector class has already been removed.\n      if (this.currentMirrorEl) {\n        this.currentMirrorEl.style.visibility = ''\n        this.currentMirrorEl = null\n      }\n    } else {\n      let mirrorEl = this.mirrorSelector\n        // TODO: somehow query FullCalendars WITHIN shadow-roots\n        ? document.querySelector(this.mirrorSelector) as HTMLElement\n        : null\n\n      if (mirrorEl) {\n        this.currentMirrorEl = mirrorEl\n        mirrorEl.style.visibility = 'hidden'\n      }\n    }\n  }\n}\n","import { ExternalElementDragging, DragMetaGenerator } from './ExternalElementDragging'\nimport { InferredElementDragging } from './InferredElementDragging'\n\nexport interface ThirdPartyDraggableSettings {\n  eventData?: DragMetaGenerator\n  itemSelector?: string\n  mirrorSelector?: string\n}\n\n/*\nBridges third-party drag-n-drop systems with FullCalendar.\nMust be instantiated and destroyed by caller.\n*/\nexport class ThirdPartyDraggable {\n  dragging: InferredElementDragging\n\n  constructor(\n    containerOrSettings?: EventTarget | ThirdPartyDraggableSettings,\n    settings?: ThirdPartyDraggableSettings,\n  ) {\n    let containerEl: EventTarget = document\n\n    if (\n      // wish we could just test instanceof EventTarget, but doesn't work in IE11\n      containerOrSettings === document ||\n      containerOrSettings instanceof Element\n    ) {\n      containerEl = containerOrSettings as EventTarget\n      settings = settings || {}\n    } else {\n      settings = (containerOrSettings || {}) as ThirdPartyDraggableSettings\n    }\n\n    let dragging = this.dragging = new InferredElementDragging(containerEl as HTMLElement)\n\n    if (typeof settings.itemSelector === 'string') {\n      dragging.pointer.selector = settings.itemSelector\n    } else if (containerEl === document) {\n      dragging.pointer.selector = '[data-event]'\n    }\n\n    if (typeof settings.mirrorSelector === 'string') {\n      dragging.mirrorSelector = settings.mirrorSelector\n    }\n\n    new ExternalElementDragging(dragging, settings.eventData) // eslint-disable-line no-new\n  }\n\n  destroy() {\n    this.dragging.destroy()\n  }\n}\n"],"sourceRoot":""}